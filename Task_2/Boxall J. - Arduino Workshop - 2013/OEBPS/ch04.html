<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 4. Building Blocks</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Arduino Workshop: A hands-on introduction with 65 projects"/><link rel="prev" href="ch03.html" title="Chapter 3. First Steps"/><link rel="next" href="ch05.html" title="Chapter 5. Working with Functions"/></head><body><section class="chapter" title="Chapter 4. Building Blocks" epub:type="chapter" id="building_blocks"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Building Blocks</h2></div></div></div><p>In this chapter you will</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Learn how to read schematic diagrams, the language of electronic circuits</p></li><li class="listitem"><p>Be introduced to the capacitor</p></li><li class="listitem"><p>Work with input pins</p></li><li class="listitem"><p>Use arithmetic and test values</p></li><li class="listitem"><p>Make decisions with <code class="literal">if-then-else</code> statements</p></li><li class="listitem"><p>Learn the difference between analog and digital</p></li><li class="listitem"><p>Measure analog voltage sources at different levels of precision</p></li><li class="listitem"><p>Be introduced to variable resistors, piezoelectric buzzers, and temperature sensors</p></li><li class="listitem"><p>Consolidate your knowledge by creating traffic lights, a battery tester, and a thermometer</p></li></ul></div><p><a id="iddle1435" class="indexterm"/>The information in this chapter will help you understand an Arduino’s potential. We’ll continue to learn more about electronics, including information about new components, how to read schematic diagrams (the “road maps” of electronic circuits), and the types of signals that can be measured. Then, we’ll discuss additional Arduino functions—such as storing values, performing mathematical operations, and making decisions. Finally, we’ll examine some more components and then put them to use in some useful projects.</p><div class="sect1" title="Using Schematic Diagrams"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="using_schematic_diagrams">Using Schematic Diagrams</h2></div></div></div><p><a class="xref" href="ch03.html" title="Chapter 3. First Steps">Chapter 3</a> described how to build a circuit using physical layout diagrams to represent the breadboard and components mounted on it. Although such physical layout diagrams may seem like the easiest way to diagram a circuit, you’ll find that as more components are added, direct representations can make physical diagrams a real mess. Because our circuits are about to get more complicated, we’ll start using <span class="emphasis"><em>schematic diagrams</em></span> (also known as <span class="emphasis"><em>circuit diagrams</em></span>) to illustrate them, such as the one shown in <a class="xref" href="ch04.html#example_of_a_schematic_diagram" title="Figure 4-1. Example of a schematic diagram">Figure 4-1</a>.</p><div class="figure"><a id="example_of_a_schematic_diagram"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00061"/><img src="httpatomoreillycomsourcenostarchimages1629884.png.jpg" alt="Example of a schematic diagram"/></div></div><div class="figure-title">Figure 4-1. Example of a schematic diagram</div></div><p>Schematics are simply circuit “road maps” that show the path of electrical current flowing through various components. Instead of showing components and wires, a schematic uses symbols and lines.</p><div class="sect2" title="Identifying Components"><div class="titlepage"><div><div><h3 class="title" id="identifying_components">Identifying Components</h3></div></div></div><p>Once you know what the symbols mean, reading a schematic is easy. To begin, let’s examine the symbols for the components we’ve already used.</p><div class="sect3" title="The Arduino"><div class="titlepage"><div><div><h4 class="title" id="arduino">The Arduino</h4></div></div></div><p><a class="xref" href="ch04.html#arduino_uno_symbol" title="Figure 4-2. Arduino Uno symbol">Figure 4-2</a> shows a symbol for the Arduino itself. As you can see, all of the Arduino’s connections are displayed and neatly labeled.</p><div class="figure"><a id="arduino_uno_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00062"/><img src="httpatomoreillycomsourcenostarchimages1629886.png.jpg" alt="Arduino Uno symbol"/></div></div><div class="figure-title">Figure 4-2. Arduino Uno symbol</div></div></div><div class="sect3" title="The Resistor"><div class="titlepage"><div><div><h4 class="title" id="resistor-id00012">The Resistor</h4></div></div></div><p><a id="iddle1066" class="indexterm"/><a id="iddle1156" class="indexterm"/><a id="iddle1178" class="indexterm"/><a id="iddle1330" class="indexterm"/><a id="iddle1426" class="indexterm"/>The resistor symbol is shown in <a class="xref" href="ch04.html#resistor_symbol" title="Figure 4-3. Resistor symbol">Figure 4-3</a>.</p><p>It’s good practice to display the resistor value and part designator along with the resistor symbol (220 Ω and R1 in this case). This makes life a lot easier for everyone trying to make sense of the schematic (including you). Often you may see ohms written as <span class="emphasis"><em>R</em></span> instead—for example, 220 R.</p><div class="figure"><a id="resistor_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00063"/><img src="httpatomoreillycomsourcenostarchimages1629888.png.jpg" alt="Resistor symbol"/></div></div><div class="figure-title">Figure 4-3. Resistor symbol</div></div></div><div class="sect3" title="The Rectifier Diode"><div class="titlepage"><div><div><h4 class="title" id="rectifier_diode-id00013">The Rectifier Diode</h4></div></div></div><p>The rectifier diode is shown in <a class="xref" href="ch04.html#rectifier_diode_symbol" title="Figure 4-4. Rectifier diode symbol">Figure 4-4</a>.</p><p>Recall from <a class="xref" href="ch03.html" title="Chapter 3. First Steps">Chapter 3</a> that rectifier diodes are polarized, and current flows from the anode to the cathode. On the symbol shown in <a class="xref" href="ch04.html#rectifier_diode_symbol" title="Figure 4-4. Rectifier diode symbol">Figure 4-4</a>, the anode is on the left and the cathode is on the right. An easy way to remember this is to think of current flowing toward the point of the triangle only. Current cannot flow the other way, because the vertical bar “stops” it.</p><div class="figure"><a id="rectifier_diode_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00064"/><img src="httpatomoreillycomsourcenostarchimages1629890.png.jpg" alt="Rectifier diode symbol"/></div></div><div class="figure-title">Figure 4-4. Rectifier diode symbol</div></div></div><div class="sect3" title="The LED"><div class="titlepage"><div><div><h4 class="title" id="led">The LED</h4></div></div></div><p>The LED symbol is shown in <a class="xref" href="ch04.html#led_symbol" title="Figure 4-5. LED symbol">Figure 4-5</a>.</p><p>All members of the diode family share a common symbol: the triangle and vertical line. However, LED symbols show two parallel arrows pointing away from the triangle to indicate that light is being emitted.</p><div class="figure"><a id="led_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00065"/><img src="httpatomoreillycomsourcenostarchimages1629892.png.jpg" alt="LED symbol"/></div></div><div class="figure-title">Figure 4-5. LED symbol</div></div></div><div class="sect3" title="The Transistor"><div class="titlepage"><div><div><h4 class="title" id="transistor-id00014">The Transistor</h4></div></div></div><p><a id="iddle1197" class="indexterm"/><a id="iddle1205" class="indexterm"/><a id="iddle1419" class="indexterm"/><a id="iddle1533" class="indexterm"/>The transistor symbol is shown in <a class="xref" href="ch04.html#transistor_symbol" title="Figure 4-6. Transistor symbol">Figure 4-6</a>. We’ll use this to represent our BC548.</p><p>The vertical line at the top of the symbol (labeled <span class="emphasis"><em>C</em></span>) represents the collector, the horizontal line at the left represents the base (labeled <span class="emphasis"><em>B</em></span>), and the bottom line represents the emitter (labeled <span class="emphasis"><em>E</em></span>). The arrow inside the symbol, pointing down and to the right, tells us that this is an <span class="emphasis"><em>NPN</em></span>-type transistor, because NPN transistors allow current to flow from the collector to the emitter. (<span class="emphasis"><em>PNP</em></span>-type transistors allow current to flow from the emitter to collector.)</p><div class="figure"><a id="transistor_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00066"/><img src="httpatomoreillycomsourcenostarchimages1629894.png.jpg" alt="Transistor symbol"/></div></div><div class="figure-title">Figure 4-6. Transistor symbol</div></div><p>When numbering transistors, we use the letter <span class="emphasis"><em>Q</em></span>, just as we use <span class="emphasis"><em>R</em></span> to number resistors.</p></div><div class="sect3" title="The Relay"><div class="titlepage"><div><div><h4 class="title" id="relay-id00015">The Relay</h4></div></div></div><p>The relay symbol is shown in <a class="xref" href="ch04.html#relay_symbol" title="Figure 4-7. Relay symbol">Figure 4-7</a>.</p><p>Relay symbols can vary in many ways and may have more than one set of contacts, but all relay symbols share certain elements in common. The first is the <span class="emphasis"><em>coil</em></span>, which is the curvy vertical line at the left. The second element is the relay <span class="emphasis"><em>contacts</em></span>. The <span class="emphasis"><em>COM</em></span> (for common) contact is often used as an input, and the contacts marked <span class="emphasis"><em>NO</em></span> (normally open) and <span class="emphasis"><em>NC</em></span> (normally closed) are often used as outputs.</p><div class="figure"><a id="relay_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00067"/><img src="httpatomoreillycomsourcenostarchimages1629896.png.jpg" alt="Relay symbol"/></div></div><div class="figure-title">Figure 4-7. Relay symbol</div></div><p>The relay symbol is always shown with the relay in the off state and the coil not <span class="emphasis"><em>energized</em></span>—that is, with the COM and NC pins connected. When the relay coil is energized, the COM and NO pins will be connected in the symbol.</p></div></div><div class="sect2" title="Wires in Schematics"><div class="titlepage"><div><div><h3 class="title" id="wires_in_schematics">Wires in Schematics</h3></div></div></div><p>When wires cross or connect in schematics, they are drawn in particular ways, as shown in the following examples.</p><div class="sect3" title="Crossing but Not Connected Wires"><div class="titlepage"><div><div><h4 class="title" id="crossing_but_not_connected_wires">Crossing but Not Connected Wires</h4></div></div></div><p><a id="iddle1259" class="indexterm"/>When two wires cross but are not connected, the crossing can be represented in one of two ways, as shown in <a class="xref" href="ch04.html#nonconnecting_crossed_wires" title="Figure 4-8. Nonconnecting crossed wires">Figure 4-8</a>. There is no one right way; it’s a matter of preference.</p><div class="figure"><a id="nonconnecting_crossed_wires"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00068"/><img src="httpatomoreillycomsourcenostarchimages1629898.png.jpg" alt="Nonconnecting crossed wires"/></div></div><div class="figure-title">Figure 4-8. Nonconnecting crossed wires</div></div></div><div class="sect3" title="Connected Wires"><div class="titlepage"><div><div><h4 class="title" id="connected_wires">Connected Wires</h4></div></div></div><p>When wires are meant to be physically connected, a <span class="emphasis"><em>junction dot</em></span> is drawn at the point of connection, as shown in <a class="xref" href="ch04.html#two_wires_that_are_connected" title="Figure 4-9. Two wires that are connected">Figure 4-9</a>.</p><div class="figure"><a id="two_wires_that_are_connected"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00069"/><img src="httpatomoreillycomsourcenostarchimages1629900.png.jpg" alt="Two wires that are connected"/></div></div><div class="figure-title">Figure 4-9. Two wires that are connected</div></div></div><div class="sect3" title="Wire Connected to Ground"><div class="titlepage"><div><div><h4 class="title" id="wire_connected_to_ground">Wire Connected to Ground</h4></div></div></div><p>When a wire is connected back to ground (GND), the standard method is to use the symbol shown in <a class="xref" href="ch04.html#gnd_symbol" title="Figure 4-10. The GND symbol">Figure 4-10</a>.</p><p>The GND symbol at the end of a line in a schematic tells you that the wire is physically connected to the Arduino GND pin.</p><div class="figure"><a id="gnd_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00070"/><img src="httpatomoreillycomsourcenostarchimages1629902.png.jpg" alt="The GND symbol"/></div></div><div class="figure-title">Figure 4-10. The GND symbol</div></div></div></div><div class="sect2" title="Dissecting a Schematic"><div class="titlepage"><div><div><h3 class="title" id="dissecting_a_schematic">Dissecting a Schematic</h3></div></div></div><p>Now that you know the symbols for various components and their connections, let’s dissect the schematic we would draw for Project 1. Recall that you made five LEDs blink backward and forward.</p><p>Compare the schematic shown in <a class="xref" href="ch04.html#schematic_for_project_1" title="Figure 4-11. Schematic for Project 1">Figure 4-11</a> with <a class="xref" href="ch03.html#circuit_layout_for_project_1" title="Figure 3-13. Circuit layout for Project 1">Figure 3-13</a>, and you’ll probably agree that using a schematic is a much easier way to describe a circuit.</p><p>From now on, we’ll use schematics to describe circuits, and we’ll show the symbols for new components as they’re introduced.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><span class="emphasis"><em>If you’d like to create your own computer-drawn schematics, try the Fritzing application, available for free from</em></span> <a class="ulink" href="http://www.fritzing.org/" target="_top">http://www.fritzing.org/</a>.</p></div><div class="figure"><a id="schematic_for_project_1"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00071"/><img src="httpatomoreillycomsourcenostarchimages1629904.png.jpg" alt="Schematic for Project 1"/></div></div><div class="figure-title">Figure 4-11. Schematic for Project 1</div></div></div></div><div class="sect1" title="The Capacitor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="capacitor">The Capacitor</h2></div></div></div><p><a id="iddle1106" class="indexterm"/><a id="iddle1111" class="indexterm"/><a id="iddle1171" class="indexterm"/>A <span class="emphasis"><em>capacitor</em></span> is a device that holds an electric charge. It consists of two metal plates with an insulating layer that allows an electric charge to build up between the plates. Once the current is stopped, the charge remains and can flow out of the capacitor (called <span class="emphasis"><em>discharging</em></span> the capacitor) as soon as the charge voltage stored in the capacitor is presented with a new path for the current to take.</p><div class="sect2" title="Measuring the Capacity of a Capacitor"><div class="titlepage"><div><div><h3 class="title" id="measuring_the_capacity_of_a_capacitor">Measuring the Capacity of a Capacitor</h3></div></div></div><p>The amount of charge that a capacitor can store is measured in <span class="emphasis"><em>farads</em></span>, and one farad is actually a very large amount. Therefore, you will generally find capacitors with values measured in picofarads or microfarads. <a id="iddle1107" class="indexterm"/><a id="iddle1108" class="indexterm"/><a id="iddle1112" class="indexterm"/><a id="iddle1217" class="indexterm"/>One <span class="emphasis"><em>picofarad</em></span> (pF) is 0.000000000001 of a farad, and one <span class="emphasis"><em>microfarad</em></span> (µF) is 0.000001 of a farad. Capacitors are also manufactured to accept certain voltage maximums. In this book, we’ll be working with low voltages only, so we won’t be using capacitors rated at greater than 10 V or so; it’s generally fine, however, to use higher-voltage specification capacitors in lower-voltage circuits. Common voltage ratings are 10, 16, 25, and 50 V.</p></div><div class="sect2" title="Reading Capacitor Values"><div class="titlepage"><div><div><h3 class="title" id="reading_capacitor_values">Reading Capacitor Values</h3></div></div></div><p>Reading the value of a ceramic capacitor takes some practice, because the value is printed in a sort of code. The first two digits represent the value in picofarads, and the third digit is the multiplier in tens. For example, the capacitor shown in <a class="xref" href="ch04.html#zerodot1_microf_ceramic_capacitor" title="Figure 4-12. A 0.1 µF ceramic capacitor">Figure 4-12</a> is labeled <span class="emphasis"><em>104</em></span>. This equates to 10, followed by four zeros, which equals 100,000 picofarads/pF (100 nanofarads [nF], or 0.1 microfarads [µF]).</p><div class="figure"><a id="zerodot1_microf_ceramic_capacitor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00072"/><img src="httpatomoreillycomsourcenostarchimages1629906.png.jpg" alt="A 0.1 µF ceramic capacitor"/></div></div><div class="figure-title">Figure 4-12. A 0.1 µF ceramic capacitor</div></div><div class="note" title="Note"><h3 class="title"><a id="ch04note02"/>Note</h3><p><span class="emphasis"><em>The conversions between units of measure can be a little confusing, but you can print an excellent conversion chart from</em></span> <a class="ulink" href="http://www.justradios.com/uFnFpF.html" target="_top">http://www.justradios.com/uFnFpF.html</a>.</p></div></div><div class="sect2" title="Types of Capacitors"><div class="titlepage"><div><div><h3 class="title" id="types_of_capacitors">Types of Capacitors</h3></div></div></div><p>Our projects will use two types of capacitors: ceramic and electrolytic.</p><div class="sect3" title="Ceramic Capacitors"><div class="titlepage"><div><div><h4 class="title" id="ceramic_capacitors">Ceramic Capacitors</h4></div></div></div><p><span class="emphasis"><em>Ceramic capacitors</em></span>, such as the one shown in <a class="xref" href="ch04.html#zerodot1_microf_ceramic_capacitor" title="Figure 4-12. A 0.1 µF ceramic capacitor">Figure 4-12</a>, are very small and therefore hold a small amount of charge. They are not polarized and can be used for current flowing in either direction. The schematic symbol for a nonpolarized capacitor is shown in <a class="xref" href="ch04.html#nonpolarized_capacitor_schematic_symbolc" title="Figure 4-13. A nonpolarized capacitor schematic symbol, with the capacitor’s value shown at the upper right">Figure 4-13</a>.</p><div class="figure"><a id="nonpolarized_capacitor_schematic_symbolc"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00073"/><img src="httpatomoreillycomsourcenostarchimages1629908.png.jpg" alt="A nonpolarized capacitor schematic symbol, with the capacitor’s value shown at the upper right"/></div></div><div class="figure-title">Figure 4-13. A nonpolarized capacitor schematic symbol, with the capacitor’s value shown at the upper right</div></div><p>Ceramic capacitors work beautifully in high-frequency circuits because they can charge and discharge very quickly due to their small capacitance.</p></div><div class="sect3" title="Electrolytic Capacitors"><div class="titlepage"><div><div><h4 class="title" id="electrolytic_capacitors">Electrolytic Capacitors</h4></div></div></div><p><a id="iddle1109" class="indexterm"/><a id="iddle1110" class="indexterm"/><span class="emphasis"><em>Electrolytic capacitors</em></span>, like the one shown in <a class="xref" href="ch04.html#electrolytic_capacitor" title="Figure 4-14. Electrolytic capacitor">Figure 4-14</a>, are physically larger than ceramic types, offer increased capacitance, and are polarized. A marking on the cover shows either the positive (+) side or negative side (–). In <a class="xref" href="ch04.html#electrolytic_capacitor" title="Figure 4-14. Electrolytic capacitor">Figure 4-14</a>, you can see the stripe and the small negative (–) symbol that identifies the negative side. Like resistors, capacitors also have a level of tolerance with their values. The capacitor in <a class="xref" href="ch04.html#electrolytic_capacitor" title="Figure 4-14. Electrolytic capacitor">Figure 4-14</a> has a tolerance of 20 percent and a capacitance of 100 µF.</p><div class="figure"><a id="electrolytic_capacitor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00074"/><img src="httpatomoreillycomsourcenostarchimages1629910.png.jpg" alt="Electrolytic capacitor"/></div></div><div class="figure-title">Figure 4-14. Electrolytic capacitor</div></div><p>The schematic symbol for electrolytic capacitors, shown in <a class="xref" href="ch04.html#polarized_capacitor_schematic_symbol" title="Figure 4-15. Polarized capacitor schematic symbol">Figure 4-15</a>, includes the + symbol to indicate the capacitor’s polarity.</p><div class="figure"><a id="polarized_capacitor_schematic_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00075"/><img src="httpatomoreillycomsourcenostarchimages1629912.png.jpg" alt="Polarized capacitor schematic symbol"/></div></div><div class="figure-title">Figure 4-15. Polarized capacitor schematic symbol</div></div><p>Electrolytic capacitors are often used to store larger electric charges and to smooth power supply voltages. Like a small temporary battery, they can provide power-supply smoothing and stability near circuits or parts that draw high currents quickly from the supply. This prevents unwanted dropouts and noise in your circuits. Luckily, the values of the electrolytic capacitor are printed clearly on the outside and don’t require decoding or interpretation.</p><p>Now that you have experience generating basic forms of output using LEDs with your Arduino, it’s time to learn how to send input from the outside world into your Arduino using digital inputs and to make decisions based on that input.</p></div></div></div><div class="sect1" title="Digital Inputs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="digital_inputs">Digital Inputs</h2></div></div></div><p><a id="iddle1103" class="indexterm"/><a id="iddle1147" class="indexterm"/><a id="iddle1195" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1399" class="indexterm"/><a id="iddle1400" class="indexterm"/>In <a class="xref" href="ch03.html" title="Chapter 3. First Steps">Chapter 3</a>, we used digital I/O pins as outputs to turn LEDs on and off. We can use these same pins to accept input from users—such as detecting whether a push button has been pressed by a user.</p><p>Like digital outputs, digital inputs have two states: high and low. The simplest form of digital input is a push button, like those shown in <a class="xref" href="ch04.html#basic_push_buttons_on_a_breadboard" title="Figure 4-16. Basic push buttons on a breadboard">Figure 4-16</a>. You can insert these directly into your solderless breadboard. A <span class="emphasis"><em>push button</em></span> allows a voltage or current to pass when the button is pressed, and digital input pins are used to detect the presence of the voltage and to determine whether a button is pressed.</p><div class="figure"><a id="basic_push_buttons_on_a_breadboard"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00076"/><img src="httpatomoreillycomsourcenostarchimages1629914.png.jpg" alt="Basic push buttons on a breadboard"/></div></div><div class="figure-title">Figure 4-16. Basic push buttons on a breadboard</div></div><p>Notice how the button at the bottom of the figure is inserted into the breadboard, bridging rows 23 and 25. When the button is pressed, it connects the two rows. The schematic symbol for this particular push button is shown in <a class="xref" href="ch04.html#push-button_schematic_symbol" title="Figure 4-17. Push-button schematic symbol">Figure 4-17</a>. The symbol represents the two sides of the button, which are numbered with the prefix S. When the button is pressed, the line bridges the two halves and allows voltage or current through.</p><div class="figure"><a id="push-button_schematic_symbol"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00077"/><img src="httpatomoreillycomsourcenostarchimages1629916.png.jpg" alt="Push-button schematic symbol"/></div></div><div class="figure-title">Figure 4-17. Push-button schematic symbol</div></div><div class="sidebar"><a id="measuring_switch_bounce_with_a_digital_s"/><div class="sidebar-title">Measuring Switch Bounce with a Digital Storage Oscilloscope</div><p><a id="iddle1376" class="indexterm"/><a id="iddle1497" class="indexterm"/>Push buttons exhibit a phenomenon called <span class="emphasis"><em>switch bounce</em></span>, or <span class="emphasis"><em>bouncing</em></span>, which refers to a button’s tendency to turn on and off several times after being pressed only once by the user. This phenomenon occurs because the metal contacts inside a push button are so small that they can vibrate after a button has been released, thereby switching on and off again very quickly.</p><p>Switch bounce can be demonstrated with a <span class="emphasis"><em>digital storage oscilloscope (DSO)</em></span>, a device that displays the change in a voltage over a period of time. For example, consider <a class="xref" href="ch04.html#measuring_switch_bounce" title="Figure 4-18. Measuring switch bounce">Figure 4-18</a>, a DSO displaying a switch bounce.</p><div class="figure"><a id="measuring_switch_bounce"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00078"/><img src="httpatomoreillycomsourcenostarchimages1629918.png.jpg" alt="Measuring switch bounce"/></div></div><div class="figure-title">Figure 4-18. Measuring switch bounce</div></div><p>The top half of the display in <a class="xref" href="ch04.html#measuring_switch_bounce" title="Figure 4-18. Measuring switch bounce">Figure 4-18</a> shows the results of pressing a button several times. When the voltage line indicated by the arrows is at the higher horizontal position (5 V), the button is in the <span class="emphasis"><em>on</em></span> state and the voltage is connected through it. Underneath the word <span class="emphasis"><em>Stop</em></span> is a slice of time just after the button was switched off, as shown by two vertical lines. The button voltage during this time is magnified in the bottom half of the screen. At A, the button is released by the user and the line drops down to 0 V. However, as you can see, due to physical vibration, the button is again at the higher 5 V position until B, where it vibrates off and then on again until C, where it settles at the low (off) state. In effect, instead of relaying one button press to our Arduino, in this case, we have unwittingly sent three.</p></div></div><div class="sect1" title="Project #4: Demonstrating a Digital Input"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash4_demonstrating_a_digital_in">Project #4: Demonstrating a Digital Input</h2></div></div></div><p><a id="iddle1391" class="indexterm"/><a id="iddle1401" class="indexterm"/><a id="iddle1424" class="indexterm"/>Our goal in this project is to create a button that turns on an LED for half a second when pressed.</p><div class="sect2" title="The Algorithm"><div class="titlepage"><div><div><h3 class="title" id="algorithm-id00016">The Algorithm</h3></div></div></div><p>Here is our algorithm:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Test to see if the button has been pressed.</p></li><li class="listitem"><p>If the button has been pressed, then turn on the LED for half a second, and then turn it off.</p></li><li class="listitem"><p>If the button has not been pressed, then do nothing.</p></li><li class="listitem"><p>Repeat indefinitely.</p></li></ol></div></div><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00017">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>One push button</p></li><li class="listitem"><p>One LED</p></li><li class="listitem"><p>One 560 Ω resistor</p></li><li class="listitem"><p>One 10 kΩ resistor</p></li><li class="listitem"><p>One 100 nF capacitor</p></li><li class="listitem"><p>Various connecting wires</p></li><li class="listitem"><p>One breadboard</p></li><li class="listitem"><p>Arduino and USB cable</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00018">The Schematic</h3></div></div></div><p>First we create the circuit on the breadboard with the schematic shown in <a class="xref" href="ch04.html#schematic_for_project_4" title="Figure 4-19. Schematic for Project 4">Figure 4-19</a>. Notice how the 10 kΩ resistor is connected between GND and digital pin seven. We call this a <span class="emphasis"><em>pull-down resistor,</em></span> because it pulls the voltage at the digital pin almost to zero. Furthermore, by adding a 100 nF capacitor across the 10 kΩ resistor, we create a simple <span class="emphasis"><em>debounce</em></span> circuit to help filter out the switch bounce. When the button is pressed, the digital pin goes immediately to high. But when the button is released, digital pin seven is pulled down to GND via the 10 kΩ resistor, and the 100 nF capacitor creates a small delay. This effectively covers up the bouncing pulses by slowing down the voltage falling to GND, thereby eliminating most of the false readings due to floating voltage and erratic button behavior.</p><div class="figure"><a id="schematic_for_project_4"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00079"/><img src="httpatomoreillycomsourcenostarchimages1629920.png.jpg" alt="Schematic for Project 4"/></div></div><div class="figure-title">Figure 4-19. Schematic for Project 4</div></div><p><a id="iddle1398" class="indexterm"/>Because this is the first time you’re building a circuit with a schematic, follow these step-by-step instructions as you walk through the schematic; this should help you understand how the components connect:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Insert the push button into the breadboard, as shown in <a class="xref" href="ch04.html#push_button_inserted_into_breadboard" title="Figure 4-20. Push button inserted into breadboard">Figure 4-20</a>.</p></li><li class="listitem"><p>Turn the breadboard 90 degrees counterclockwise and insert the 10 kΩ resistor, a short link wire, and the capacitor, as shown in <a class="xref" href="ch04.html#one0_kohm_resistorcomma_capacitorcomma_a" title="Figure 4-21. 10 kΩ resistor, capacitor, and push button">Figure 4-21</a>.</p><div class="figure"><a id="push_button_inserted_into_breadboard"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00080"/><img src="httpatomoreillycomsourcenostarchimages1629922.png.jpg" alt="Push button inserted into breadboard"/></div></div><div class="figure-title">Figure 4-20. Push button inserted into breadboard</div></div><div class="figure"><a id="one0_kohm_resistorcomma_capacitorcomma_a"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00081"/><img src="httpatomoreillycomsourcenostarchimages1629924.png.jpg" alt="10 kΩ resistor, capacitor, and push button"/></div></div><div class="figure-title">Figure 4-21. 10 kΩ resistor, capacitor, and push button</div></div></li><li class="listitem"><p>Connect one wire from the Arduino 5 V pin to the leftmost vertical column on the breadboard, and connect another wire from the Arduino GND pin to the vertical row to the right of the 5 V column, as shown in <a class="xref" href="ch04.html#five_v_left_parenthesisredright_parenthe" title="Figure 4-22. The 5 V (red) and GND (black) wires">Figure 4-22</a>.</p><div class="figure"><a id="five_v_left_parenthesisredright_parenthe"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00082"/><img src="httpatomoreillycomsourcenostarchimages1629926.png.jpg" alt="The 5 V (red) and GND (black) wires"/></div></div><div class="figure-title">Figure 4-22. The 5 V (red) and GND (black) wires</div></div></li><li class="listitem"><p>Run a wire from Arduino digital pin 7 to the breadboard near the top-right corner of the button, as shown in <a class="xref" href="ch04.html#connecting_the_button_to_the_digital_inp" title="Figure 4-23. Connecting the button to the digital input">Figure 4-23</a>.</p><div class="figure"><a id="connecting_the_button_to_the_digital_inp"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00083"/><img src="httpatomoreillycomsourcenostarchimages1629928.png.jpg" alt="Connecting the button to the digital input"/></div></div><div class="figure-title">Figure 4-23. Connecting the button to the digital input</div></div></li><li class="listitem"><p>Insert the LED into the breadboard with the short leg (the cathode) connected to the GND column, and the long leg (the anode) in a row to the right. Next, connect the 560 Ω resistor to the right of the LED, as shown in <a class="xref" href="ch04.html#inserting_the_led_and_560_ohm_resistor" title="Figure 4-24. Inserting the LED and 560 Ω resistor">Figure 4-24</a>.</p><div class="figure"><a id="inserting_the_led_and_560_ohm_resistor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00084"/><img src="httpatomoreillycomsourcenostarchimages1629930.png.jpg" alt="Inserting the LED and 560 Ω resistor"/></div></div><div class="figure-title">Figure 4-24. Inserting the LED and 560 Ω resistor</div></div></li><li class="listitem"><p>Connect a wire from the right side of the 560 Ω resistor to Arduino digital pin 12, as shown in <a class="xref" href="ch04.html#connecting_the_led_branch_to_the_arduino" title="Figure 4-25. Connecting the LED branch to the Arduino">Figure 4-25</a>.</p><div class="figure"><a id="connecting_the_led_branch_to_the_arduino"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00085"/><img src="httpatomoreillycomsourcenostarchimages1629932.png.jpg" alt="Connecting the LED branch to the Arduino"/></div></div><div class="figure-title">Figure 4-25. Connecting the LED branch to the Arduino</div></div></li></ol></div><p>Before continuing, review the schematic for this circuit and check that your components are wired correctly. Compare the schematic against the actual wiring of the circuit.</p></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00019">The Sketch</h3></div></div></div><p>For the sketch, enter and upload <a class="xref" href="ch04.html#digital_input" title="Example 4-1. Digital input">Example 4-1</a>:</p><div class="example"><a id="digital_input"/><div class="example-title">Example 4-1. Digital input</div><div class="example-contents"><pre class="programlisting">  // Project 4 - Demonstrating a Digital Input
<span class="gray-background">1</span> #define LED    12
  #define BUTTON 7

  void setup()
  {
<span class="gray-background">2</span>   pinMode(LED, OUTPUT);   // output for the LED
    pinMode(BUTTON, INPUT); // input for the button
  }

  void loop()
  {
    if ( digitalRead(BUTTON) == HIGH )
    {
      digitalWrite(LED, HIGH);   // turn on the LED
      delay(500);                // wait for 0.5 seconds
      digitalWrite(LED, LOW);    // turn off the LED
    }
  }</pre></div></div><p><a id="iddle1013" class="indexterm"/><a id="iddle1135" class="indexterm"/><a id="iddle1142" class="indexterm"/><a id="iddle1148" class="indexterm"/><a id="iddle1149" class="indexterm"/>After you’ve uploaded your sketch, tap the push button briefly and your LED should stay on for half a second.</p></div><div class="sect2" title="Modifying Your Sketch"><div class="titlepage"><div><div><h3 class="title" id="modifying_your_sketch-id00020">Modifying Your Sketch</h3></div></div></div><p>Once you’ve had some success, try modifying your sketch by changing the length of time that the light stays on or by adding a push button control to Project 3. (Don’t disassemble this circuit, though; we’ll use it again in the next example.)</p></div><div class="sect2" title="Understanding the Sketch"><div class="titlepage"><div><div><h3 class="title" id="understanding_the_sketch">Understanding the Sketch</h3></div></div></div><p>Let’s examine the new items in the sketch for Project 4—specifically, <code class="literal">#define</code>, digital input pins, and the <code class="literal">if-then</code> function.</p></div><div class="sect2" title="Creating Constants with #define"><div class="titlepage"><div><div><h3 class="title" id="creating_constants_with_hashdefine">Creating Constants with #define</h3></div></div></div><p>Before <code class="literal">void setup()</code>, we use <code class="literal">#define</code> statements at <span class="gray-background">1</span> to create fixed variables: When the sketch is compiled, the IDE replaces any instance of the defined word with the number that follows it. For example, when the IDE sees <code class="literal">LED</code> in the line at <span class="gray-background">2</span>, it replaces it with the number <code class="literal">12</code>.</p><p>We’re basically using the <code class="literal">#define</code> command to label the digital pins for the LED and button in the sketch. Also notice that we do not use a semicolon after a <code class="literal">#define</code> value. It’s a good idea to label pin numbers and other fixed values (such as a time delay) in this way, because if the value is used repeatedly in the sketch, then you won’t have to edit the same item more than once. In this example, <code class="literal">LED</code> is used three times in the sketch; to edit this value, we’d simply have to change its definition once in its <code class="literal">#define</code> statement.</p></div><div class="sect2" title="Reading Digital Input Pins"><div class="titlepage"><div><div><h3 class="title" id="reading_digital_input_pins">Reading Digital Input Pins</h3></div></div></div><p>To read the status of a button, we first define a digital I/O pin as an input in <code class="literal">void setup()</code> using the following:</p><a id="pro_id00015"/><pre class="programlisting">pinMode(BUTTON, INPUT); // input for button</pre><p>Next, to discover whether the button is connecting a voltage through to the digital input (that is, it’s being pressed), we use <code class="literal">digitalRead(</code><span class="emphasis"><em><code class="literal">pin</code></em></span><code class="literal">)</code>, where <span class="emphasis"><em><code class="literal">pin</code></em></span> is the digital pin number to read. The function returns either <code class="literal">HIGH</code> (voltage is close to 5 V at the pin) or <code class="literal">LOW</code> (voltage is close to 0 V at the pin).</p></div><div class="sect2" title="Making Decisions with if"><div class="titlepage"><div><div><h3 class="title" id="making_decisions_with_if">Making Decisions with if</h3></div></div></div><p><a id="iddle1005" class="indexterm"/><a id="iddle1007" class="indexterm"/><a id="iddle1211" class="indexterm"/><a id="iddle1272" class="indexterm"/><a id="iddle1511" class="indexterm"/>Using <code class="literal">if</code>, we can make decisions in our sketch and tell the Arduino to run different code, depending on the decision. For example, in the sketch for Project 4, we used <a class="xref" href="ch04.html#simple_if-then_example" title="Example 4-2. A simple if-then example">Example 4-2</a>:</p><div class="example"><a id="simple_if-then_example"/><div class="example-title">Example 4-2. A simple <code class="literal">if-then</code> example</div><div class="example-contents"><pre class="programlisting">// Listing 4-2
if (digitalRead(BUTTON) == HIGH)
{
    digitalWrite(LED, HIGH);    // turn on the LED
    delay(500);                 // wait for 0.5 seconds
    digitalWrite(LED, LOW);     // turn off the LED
}</pre></div></div><p>The first line in the code begins with <code class="literal">if</code> tests for a condition. If the condition is true (that is, voltage is <code class="literal">HIGH</code>), then it means that the button is pressed and the code that follows inside the curly brackets will run.</p><p>To determine whether the button is pressed (<code class="literal">digitalRead(BUTTON)</code> is set to <code class="literal">HIGH</code>), we use a <span class="emphasis"><em>comparison operator,</em></span> a double equal sign (<code class="literal">==</code>). If we were to replace <code class="literal">==</code> with <code class="literal">!=</code> (not equal to) in the sketch, then the LED would turn off when the button is pressed instead. Try it and see.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note03"/>Note</h3><p><span class="emphasis"><em>A common mistake is to use a single equal sign (<code class="literal">=</code>), which means “make equal to,” in a test statement instead of a double equal sign (<code class="literal">==</code>), which says “test if it is equal to.” You may not get an error message, but your <code class="literal">if</code> statement may not work!</em></span></p></div></div><div class="sect2" title="Making More Decisions with if-then-else"><div class="titlepage"><div><div><h3 class="title" id="making_more_decisions_with_if-then-else">Making More Decisions with if-then-else</h3></div></div></div><p>You can add another action to an <code class="literal">if</code> statement by using <code class="literal">else</code>. For example, if we rewrite <a class="xref" href="ch04.html#digital_input" title="Example 4-1. Digital input">Example 4-1</a> by adding <code class="literal">else</code> as shown in <a class="xref" href="ch04.html#adding_else" title="Example 4-3. Adding else">Example 4-3</a>, then the LED will turn on <span class="emphasis"><em>if</em></span> the button is pressed, or <span class="emphasis"><em>else</em></span> it will be off. Using <code class="literal">else</code> forces the Arduino to run another section of code if the test in the <code class="literal">if</code> statement is not true.</p><div class="example"><a id="adding_else"/><div class="example-title">Example 4-3. Adding <code class="literal">else</code></div><div class="example-contents"><pre class="programlisting">// Listing 4-3
#define LED    12
#define BUTTON 7

void setup()
{
  pinMode(LED, OUTPUT);   // output for the LED
  pinMode(BUTTON, INPUT); // input for the button
}

void loop()
{
  if ( digitalRead(BUTTON) == HIGH )
  {
    digitalWrite(LED, HIGH);
  }
  <span class="strong"><strong>else</strong></span>
  {
    digitalWrite(LED, LOW);
  }
}</pre></div></div></div></div><div class="sect1" title="Boolean Variables"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="boolean_variables">Boolean Variables</h2></div></div></div><p><a id="iddle1099" class="indexterm"/><a id="iddle1129" class="indexterm"/><a id="iddle1216" class="indexterm"/><a id="iddle1537" class="indexterm"/>Sometimes you need to record whether something is in either of only two states, such as on or off, or hot or cold. A <span class="emphasis"><em>Boolean variable</em></span> is the legendary computer “bit” whose value can be only a zero (0, false) or one (1, true). This is where the Boolean variable is useful: It can only be true or false. Like any other variable, we need to declare it in order to use it:</p><a id="pro_id00016"/><pre class="programlisting">boolean raining = true; // create the variable "raining" and first make it true</pre><p>Within the sketch, you can change the state of a Boolean with a simple reassignment, such as this:</p><a id="pro_id00017"/><pre class="programlisting">raining = false;</pre><p>It’s simple to use Boolean variables to make decisions using an <code class="literal">if</code> test structure. Because Boolean comparisons can either be true or false, they work well with the comparison operators <code class="literal">!=</code> and <code class="literal">==</code>. Here’s an example:</p><a id="pro_id00018"/><pre class="programlisting">if ( raining == true )
{
      if ( summer != true )
      {
            // it is raining and not summer
      }
}</pre><div class="sect2" title="Comparison Operators"><div class="titlepage"><div><div><h3 class="title" id="comparison_operators">Comparison Operators</h3></div></div></div><p>We can use various operators to make decisions about two or more Boolean variables or other states. These include the operators <span class="emphasis"><em>not</em></span> (<code class="literal">!</code>), <span class="emphasis"><em>and</em></span> (<code class="literal">&amp;&amp;</code>), and <span class="emphasis"><em>or</em></span> (<code class="literal">||</code>).</p><div class="sect3" title="The not Operator"><div class="titlepage"><div><div><h4 class="title" id="not_operator">The not Operator</h4></div></div></div><p><a id="iddle1002" class="indexterm"/><a id="iddle1006" class="indexterm"/><a id="iddle1021" class="indexterm"/><a id="iddle1036" class="indexterm"/><a id="iddle1131" class="indexterm"/><a id="iddle1132" class="indexterm"/><a id="iddle1133" class="indexterm"/><a id="iddle1368" class="indexterm"/><a id="iddle1374" class="indexterm"/>The <span class="emphasis"><em>not</em></span> operator is denoted by the use of an exclamation mark (<code class="literal">!</code>). This operator is used as an abbreviation for checking whether something is <span class="emphasis"><em>not true</em></span>. Here’s an example:</p><a id="pro_id00019"/><pre class="programlisting">if ( !raining  )
{
    // it is not raining (raining == false)
}</pre></div><div class="sect3" title="The and Operator"><div class="titlepage"><div><div><h4 class="title" id="and_operator">The and Operator</h4></div></div></div><p>The logical <span class="emphasis"><em>and</em></span> operator is denoted by <code class="literal">&amp;&amp;</code>. Using <span class="emphasis"><em>and</em></span> helps reduce the number of separate <code class="literal">if</code> tests. Here’s an example:</p><a id="pro_id00020"/><pre class="programlisting">if (( raining == true ) &amp;&amp; ( !summer ))
{
    // it is raining and not summer (raining == true and summer == false)
}</pre></div><div class="sect3" title="The or Operator"><div class="titlepage"><div><div><h4 class="title" id="or_operator">The or Operator</h4></div></div></div><p>The logical <span class="emphasis"><em>or</em></span> operator is denoted by <code class="literal">||</code>. Using <span class="emphasis"><em>or</em></span> is very simple; here’s an example:</p><a id="pro_id00021"/><pre class="programlisting">if (( raining == true ) || ( summer == true ))
{
    // it is either raining or summer
}</pre></div></div><div class="sect2" title="Making Two or More Comparisons"><div class="titlepage"><div><div><h3 class="title" id="making_two_or_more_comparisons">Making Two or More Comparisons</h3></div></div></div><p>You can also use two or more comparisons in the same <code class="literal">if</code>. Here’s an example:</p><a id="pro_id00022"/><pre class="programlisting">if ( snow == true &amp;&amp; rain == true &amp;&amp; !hot )
{
    // it is snowing and raining and not hot
}</pre><p>And you can use parentheses to set the orders of operation. In the next example, the comparison in the parentheses is checked first, given a true or false state, and then compared with the rest in the <code class="literal">if-then</code> statement.</p><a id="pro_id00023"/><pre class="programlisting">if (( snow == true || rain == true ) &amp;&amp; hot == false))
{
    // it is either snowing or raining and not hot
}</pre><p><a id="iddle1531" class="indexterm"/>Lastly, just like the examples of the not (<code class="literal">!</code>) operator before a value, simple tests of true or false can be performed without requiring <code class="literal">== true</code> or <code class="literal">== false</code> in each test. The following code works out the same as in the preceding example:</p><a id="pro_id00024"/><pre class="programlisting">if (( snow || rain ) &amp;&amp; !hot )
{
    // it is either snowing or raining and not hot
    // ( snow is true OR rain is true ) AND it is not hot
}</pre><p>As you can see, it’s possible to have the Arduino make a multitude of decisions using Boolean variables and comparison operators. Once you move on to more complex projects, this will become very useful.</p></div></div><div class="sect1" title="Project #5: Controlling Traffic"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash5_controlling_traffic">Project #5: Controlling Traffic</h2></div></div></div><p>Now let’s put your newfound knowledge to use by solving a hypothetical problem. As the town planner for a rural shire, you have a problem with a single-lane bridge that crosses the river. Every week, one or two accidents occur at night, when tired drivers rush across the bridge without first stopping to see if the road is clear. You have suggested that traffic lights be installed, but the mayor wants to see them demonstrated before signing off on the purchase. You could rent temporary lights, but they’re expensive. Instead, you’ve decided to build a model of the bridge with working traffic lights using LEDs and an Arduino.</p><div class="sect2" title="The Goal"><div class="titlepage"><div><div><h3 class="title" id="goal">The Goal</h3></div></div></div><p>Our goal is to install three-color traffic lights at each end of the single-lane bridge. The lights allow traffic to flow only in one direction at a time. When sensors located at either end of the bridge detect a car waiting at a red light, the lights will change and allow the traffic to flow in the opposite direction.</p></div><div class="sect2" title="The Algorithm"><div class="titlepage"><div><div><h3 class="title" id="algorithm-id00021">The Algorithm</h3></div></div></div><p>We’ll use two buttons to simulate the vehicle sensors at each end of the bridge. Each set of lights will have red, yellow, and green LEDs. Initially, the system will allow traffic to flow from west to east, so the west-facing lights will be set to green and the east-facing lights will be set to red.</p><p>When a vehicle approaches the bridge (modeled by pressing the button) and the light is red, the system will turn the light on the opposite side from green to yellow to red, and then wait a set period of time to allow any vehicles already on the bridge to finish crossing. Next, the yellow light on the waiting vehicle’s side will blink as a “get ready” notice for the driver, and finally the light will change to green. The light will remain green until a vehicle approaches the other side, at which point the process repeats.</p></div><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00022">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Two red LEDs (LED1 and LED2)</p></li><li class="listitem"><p>Two yellow LEDs (LED3 and LED4)</p></li><li class="listitem"><p>Two green LEDs (LED5 and LED6)</p></li><li class="listitem"><p>Six 560 Ω resistors (R1 to R6)</p></li><li class="listitem"><p>Two 10 kΩ resistor (R7 and R8)</p></li><li class="listitem"><p>Two 100 nF capacitors (C1 and C2)</p></li><li class="listitem"><p>Two push buttons (S1 and S2)</p></li><li class="listitem"><p>One medium-sized breadboard</p></li><li class="listitem"><p>One Arduino and USB cable</p></li><li class="listitem"><p>Various connecting wires</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00023">The Schematic</h3></div></div></div><p>Because we’re controlling only six LEDs and receiving input from two buttons, the design will not be too difficult. <a class="xref" href="ch04.html#schematic_for_project_5" title="Figure 4-26. Schematic for Project 5">Figure 4-26</a> shows the schematic for our project.</p><div class="figure"><a id="schematic_for_project_5"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00086"/><img src="httpatomoreillycomsourcenostarchimages1629934.png.jpg" alt="Schematic for Project 5"/></div></div><div class="figure-title">Figure 4-26. Schematic for Project 5</div></div><p>This circuit is basically a more elaborate version of the button and LED circuit in Project 4, with resistors, more LEDs, and another button.</p><p>Be sure that the LEDs are inserted in the correct direction: the resistors connect to LED anodes, and the LED cathodes connect to the Arduino GND pin, as shown in <a class="xref" href="ch04.html#completed_circuit" title="Figure 4-27. Completed circuit">Figure 4-27</a>.</p><div class="figure"><a id="completed_circuit"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00087"/><img src="httpatomoreillycomsourcenostarchimages1629936.png.jpg" alt="Completed circuit"/></div></div><div class="figure-title">Figure 4-27. Completed circuit</div></div></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00024">The Sketch</h3></div></div></div><p>And now for the sketch. Can you see how it matches our algorithm?</p><a id="pro_id00025"/><pre class="programlisting">  // Project 5 - Controlling Traffic

  // define the pins that the buttons and lights are connected to:
<span class="gray-background">1</span>  #define westButton 7
  #define eastButton 13
  #define westRed    2
  #define westYellow 1
  #define westGreen  0
  #define eastRed    12
  #define eastYellow 11
  #define eastGreen  10

  #define yellowBlinkTime 500 // 0.5 seconds for yellow light blink

<span class="gray-background">2</span> boolean trafficWest = true;  // west = true, east = false
<span class="gray-background">3</span> int     flowTime    = 10000; // amount of time to let traffic flow
<span class="gray-background">4</span> int     changeDelay = 2000;  // amount of time between color changes

  void setup()
  {
    // setup digital I/O pins
    pinMode(westButton, INPUT);
    pinMode(eastButton, INPUT);
    pinMode(westRed,    OUTPUT);
    pinMode(westYellow, OUTPUT);
    pinMode(westGreen,  OUTPUT);
    pinMode(eastRed,    OUTPUT);
    pinMode(eastYellow, OUTPUT);
    pinMode(eastGreen,  OUTPUT);

    // set initial state for lights - west side is green first
    digitalWrite(westRed,    LOW);
    digitalWrite(westYellow, LOW);
    digitalWrite(westGreen,  HIGH);
    digitalWrite(eastRed,    HIGH);
    digitalWrite(eastYellow, LOW);
    digitalWrite(eastGreen,  LOW);
  }

  void loop()
  {
    if ( digitalRead(westButton) == HIGH ) // request west&gt;east traffic flow
    {
      if ( trafficWest != true )
  // only continue if traffic flowing in the opposite (east) direction
      {
        trafficWest = true; // change traffic flow flag to west&gt;east
        delay(flowTime);    // give time for traffic to flow
        digitalWrite(eastGreen, LOW); // change east-facing lights from green
                                      // to yellow to red
        digitalWrite(eastYellow, HIGH);
        delay(changeDelay);
        digitalWrite(eastYellow, LOW);
        digitalWrite(eastRed, HIGH);
        delay(changeDelay);
        for ( int a = 0; a &lt; 5; a++ ) // blink yellow light
        {
          digitalWrite(westYellow, LOW);
          delay(yellowBlinkTime);
          digitalWrite(westYellow, HIGH);
          delay(yellowBlinkTime);
        }
        digitalWrite(westYellow, LOW);
        digitalWrite(westRed, LOW); // change west-facing lights from red to green
        digitalWrite(westGreen, HIGH);
      }
    }

    if ( digitalRead(eastButton) == HIGH ) // request east&gt;west traffic flow
    {
      if ( trafficWest == true )
  // only continue if traffic flow is in the opposite (west) direction
      {
        trafficWest = false; // change traffic flow flag to east&gt;west
        delay(flowTime);     // give time for traffic to flow
        digitalWrite(westGreen, LOW);
  // change west lights from green to yellow to red
        digitalWrite(westYellow, HIGH);
        delay(changeDelay);
        digitalWrite(westYellow, LOW);
        digitalWrite(westRed, HIGH);
        delay(changeDelay);
        for ( int a = 0 ; a &lt; 5 ; a++ ) // blink yellow light
        {
          digitalWrite(eastYellow, LOW);
          delay(yellowBlinkTime);
          digitalWrite(eastYellow, HIGH);
          delay(yellowBlinkTime);
        }
        digitalWrite(eastYellow, LOW);
        digitalWrite(eastRed, LOW); // change east-facing lights from red to green
        digitalWrite(eastGreen, HIGH);
      }
    }
  }</pre><p>Our sketch starts by using <code class="literal">#define</code> at <span class="gray-background">1</span> to associate digital pin numbers with labels for all the LEDs used, as well as the two buttons. We have red, yellow, and green LEDs and a button each for the west and east sides of the bridge. The Boolean variable <code class="literal">trafficWest</code> at <span class="gray-background">2</span> is used to keep track of which way the traffic is flowing—<code class="literal">true</code> is west to east, and <code class="literal">false</code> is east to west.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note04"/>Note</h3><p><span class="emphasis"><em>Notice that <code class="literal">trafficWest</code> is a single Boolean variable with the traffic direction set as either <code class="literal">true</code> or <code class="literal">false</code>. Having a single variable like this instead of two (one for east and one for west) ensures that both directions cannot accidentally be true at the same time, which helps avoid a crash!</em></span></p></div><p>The integer variable <code class="literal">flowTime</code> at <span class="gray-background">3</span> is the minimum period of time that vehicles have to cross the bridge. When a vehicle pulls up at a red light, the system delays this period to give the opposing traffic time to cross the bridge. The integer variable <code class="literal">changeDelay</code> at <span class="gray-background">4</span> is the period of time between the traffic lights switching from green to yellow to red.</p><p>Before the sketch enters the <code class="literal">void loop()</code> section, it is set for traffic to flow from west to east in <code class="literal">void setup()</code>.</p></div><div class="sect2" title="Running the Sketch"><div class="titlepage"><div><div><h3 class="title" id="running_the_sketch-id00025">Running the Sketch</h3></div></div></div><p><a id="iddle1377" class="indexterm"/>Once it’s running, the sketch does nothing until one of the buttons is pressed. When the east button is pressed, the line</p><a id="pro_id00026"/><pre class="programlisting">if ( trafficWest == true )</pre><p>ensures that the lights change only if the traffic is heading in the opposite direction. The rest of the code section is composed of a simple sequence of waiting and then of turning on and off various LEDs to simulate the trafficlight operation.</p></div></div><div class="sect1" title="Analog vs. Digital Signals"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="analog_vsdot_digital_signals">Analog vs. Digital Signals</h2></div></div></div><p>In this section, you’ll learn the difference between digital and analog signals, and you’ll learn how to measure analog signals with the analog input pins.</p><p>Until now, our sketches have been using digital electrical signals, with just two discrete levels. Specifically, we used<code class="literal"> digitalWrite(pin, HIGH)</code> and <code class="literal">digitalWrite(pin, LOW)</code> to blink an LED and <code class="literal">digitalRead()</code> to measure whether a digital pin had a voltage applied to it (<code class="literal">HIGH</code>) or not (<code class="literal">LOW</code>). <a class="xref" href="ch04.html#digital_signalcomma_with_highs_appearing" title="Figure 4-28. A digital signal, with HIGHs appearing as horizontal lines at the top, and LOWs appearing at the bottom">Figure 4-28</a> is a visual representation of a digital signal that alternates between high and low.</p><div class="figure"><a id="digital_signalcomma_with_highs_appearing"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00088"/><img src="httpatomoreillycomsourcenostarchimages1629938.png.jpg" alt="A digital signal, with HIGHs appearing as horizontal lines at the top, and LOWs appearing at the bottom"/></div></div><div class="figure-title">Figure 4-28. A digital signal, with <code class="literal">HIGH</code>s appearing as horizontal lines at the top, and <code class="literal">LOW</code>s appearing at the bottom</div></div><p>Unlike digital signals, analog signals can vary with an indefinite number of steps between high and low. For example, <a class="xref" href="ch04.html#analog_signal_of_a_sine_wave" title="Figure 4-29. An analog signal of a sine wave">Figure 4-29</a> shows an analog signal of a sine wave. Notice in the figure that as time progresses, the voltage moves fluidly between high and low levels.</p><div class="figure"><a id="analog_signal_of_a_sine_wave"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00089"/><img src="httpatomoreillycomsourcenostarchimages1629940.png.jpg" alt="An analog signal of a sine wave"/></div></div><div class="figure-title">Figure 4-29. An analog signal of a sine wave</div></div><p><a id="iddle1033" class="indexterm"/><a id="iddle1084" class="indexterm"/>With our Arduino, high is closer to 5 V and low is closer to 0 V, or GND. We can measure the voltage values of an analog signal with our Arduino using the six analog inputs shown in <a class="xref" href="ch04.html#analog_inputs_on_the_arduino_uno" title="Figure 4-30. Analog inputs on the Arduino Uno">Figure 4-30</a>. These analog inputs can safely measure voltages from 0 (GND) to no more than 5 V.</p><div class="figure"><a id="analog_inputs_on_the_arduino_uno"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00090"/><img src="httpatomoreillycomsourcenostarchimages1629942.png.jpg" alt="Analog inputs on the Arduino Uno"/></div></div><div class="figure-title">Figure 4-30. Analog inputs on the Arduino Uno</div></div><p>If you use the function <code class="literal">analogRead()</code>, then the Arduino will return a number between 0 and 1,023 in proportion to the voltage applied to the analog pin. For example, you might use <code class="literal">analogRead()</code> to store the value of analog pin zero in the integer variable <code class="literal">a</code>:</p><a id="pro_id00027"/><pre class="programlisting">   a = analogRead(0); // read analog input pin 0 (A0)
                      // returns 0 to 1023 which is usually 0.000 to 4.995
volts</pre></div><div class="sect1" title="Project #6: Creating a Single-Cell Battery Tester"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash6_creating_a_single-cell_bat">Project #6: Creating a Single-Cell Battery Tester</h2></div></div></div><p>Although the popularity and use of cell batteries has declined, most people still have a few devices around the house that use AA, AAA, C, or D cell batteries, such as remote controls, clocks, or children’s toys. These batteries carry much less than 5 V, so we can measure a cell’s voltage with our Arduino to determine the state of the cell. In this project we’ll create a battery tester.</p><div class="sect2" title="The Goal"><div class="titlepage"><div><div><h3 class="title" id="goal-id00026">The Goal</h3></div></div></div><p>Single-cell batteries such as AAs usually begin at about 1.6 V when new and then decrease with use. We will measure the voltage and express the battery condition visually with LEDs. We’ll use the reading from <code class="literal">analogRead()</code> and then convert the reading to volts. The maximum voltage that can be read is 5 V, so we divide 5 by 1,024 (the number of possible values), which equals 0.0048. Therefore, if <code class="literal">analogRead()</code> returns 512, then we multiply that reading by 0.0048, which equals 2.4576 V.</p></div><div class="sect2" title="The Algorithm"><div class="titlepage"><div><div><h3 class="title" id="algorithm-id00027">The Algorithm</h3></div></div></div><p>Here’s the algorithm for our battery tester operation:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Read from analog pin zero.</p></li><li class="listitem"><p>Multiply the reading by 0.0048 to create a voltage value.</p></li><li class="listitem"><p>If the voltage is greater than or equal to 1.6 V, then briefly turn on a green LED.</p></li><li class="listitem"><p>If the voltage is greater than 1.4 V <span class="emphasis"><em>and</em></span> less than 1.6 V, then briefly turn on a yellow LED.</p></li><li class="listitem"><p>If the voltage is less than 1.4 V, then briefly turn on a red LED.</p></li><li class="listitem"><p>Repeat indefinitely.</p></li></ol></div></div><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00028">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Three 560 Ω resistors (R1 to R3)</p></li><li class="listitem"><p>One 2.2 kΩ resistor (R4)</p></li><li class="listitem"><p>One green LED (LED1)</p></li><li class="listitem"><p>One yellow LED (LED2)</p></li><li class="listitem"><p>One red LED (LED3)</p></li><li class="listitem"><p>One breadboard</p></li><li class="listitem"><p>Various connecting wires</p></li><li class="listitem"><p>One Arduino and USB cable</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00029">The Schematic</h3></div></div></div><p>The schematic for the single-cell battery tester circuit is shown in <a class="xref" href="ch04.html#schematic_for_project_6" title="Figure 4-31. Schematic for Project 6">Figure 4-31</a>. On the left side, notice the two terminals, labeled <span class="emphasis"><em>+</em></span> and <span class="emphasis"><em>–.</em></span> Connect the <span class="emphasis"><em>matching</em></span> sides of the single-cell battery to be tested at those points. Positive should connect to positive, and negative should connect to negative.</p><div class="warning" title="Warning" epub:type="warning"><h3 class="title"><a id="ch04note05"/>Warning</h3><p><span class="emphasis"><em>Under no circumstances should you measure anything larger than 5 V, nor should you connect positive to negative, or vice versa. Doing these things will damage your Arduino board.</em></span></p></div><div class="figure"><a id="schematic_for_project_6"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00091"/><img src="httpatomoreillycomsourcenostarchimages1629944.png.jpg" alt="Schematic for Project 6"/></div></div><div class="figure-title">Figure 4-31. Schematic for Project 6</div></div></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00030">The Sketch</h3></div></div></div><p>Now for the sketch:</p><a id="pro_id00028"/><pre class="programlisting">  // Project 6 - Creating a Single-Cell Battery Tester
  #define newLED 2  // green LED  'new'
  #define okLED  4  // yellow LED 'ok'
  #define oldLED 6  // red LED    'old'

  int analogValue = 0;
<span class="gray-background">1</span> float voltage = 0;
  int ledDelay = 2000;

  void setup()
  {
    pinMode(newLED, OUTPUT);
    pinMode(okLED, OUTPUT);
    pinMode(oldLED, OUTPUT);
  }

  void loop()
  {
<span class="gray-background">2</span>   analogValue = analogRead(0);
<span class="gray-background">3</span>   voltage = 0.0048*analogValue;
<span class="gray-background">4</span>   if ( voltage &gt;= 1.6 )
    {
      digitalWrite(newLED, HIGH);
      delay(ledDelay);
      digitalWrite(newLED, LOW);
    }
<span class="gray-background">5</span>   else if ( voltage &lt; 1.6 &amp;&amp; voltage &gt; 1.4 )
    {
      digitalWrite(okLED, HIGH);
      delay(ledDelay);
      digitalWrite(okLED, LOW);
    }
<span class="gray-background">6</span>   else if ( voltage &lt;= 1.4 )
    {
      digitalWrite(oldLED, HIGH);
      delay(ledDelay);
      digitalWrite(oldLED, LOW);
    }
  }</pre><p><a id="iddle1015" class="indexterm"/><a id="iddle1019" class="indexterm"/><a id="iddle1068" class="indexterm"/>In the sketch for Project 6, the Arduino takes the value measured by analog pin 0 at <span class="gray-background">2</span> and converts this to a voltage at <span class="gray-background">3</span>. You’ll learn about a new type of variable, <code class="literal">float</code> at <span class="gray-background">1</span>, in the next section. You’ll also see some familiar code, such as the <code class="literal">if-else</code> functions, and some new topics, such as doing arithmetic and using comparison operators to compare numbers, which are all discussed in the sections that follow.</p></div></div><div class="sect1" title="Doing Arithmetic with an Arduino"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="doing_arithmetic_with_an_arduino">Doing Arithmetic with an Arduino</h2></div></div></div><p>Like a pocket calculator, the Arduino can perform calculations for us, such as multiplication, division, addition, and subtraction. Here are some examples:</p><a id="pro_id00029"/><pre class="programlisting">a = 100;
b = a + 20;
c = b - 200;
d = c + 80; // d will equal 0</pre><div class="sect2" title="Float Variables"><div class="titlepage"><div><div><h3 class="title" id="float_variables">Float Variables</h3></div></div></div><p><a id="iddle1003" class="indexterm"/><a id="iddle1008" class="indexterm"/><a id="iddle1011" class="indexterm"/><a id="iddle1012" class="indexterm"/><a id="iddle1016" class="indexterm"/><a id="iddle1017" class="indexterm"/><a id="iddle1067" class="indexterm"/><a id="iddle1130" class="indexterm"/><a id="iddle1219" class="indexterm"/><a id="iddle1415" class="indexterm"/><a id="iddle1553" class="indexterm"/>When you need to deal with numbers with a decimal point, you can use the variable type <code class="literal">float</code>. The values that can be stored in a <code class="literal">float</code> fall between 3.4028235 × 1038 and −3.4028235 × 1038, and are generally limited to six or seven decimal places of precision. And you can mix integers and <code class="literal">float</code> numbers in your calculations. For example, you could add the <code class="literal">float</code> number <code class="literal">f</code> to the integer <code class="literal">a</code> then store it as the <code class="literal">float</code> variable <code class="literal">g</code>:</p><a id="pro_id00030"/><pre class="programlisting">int a = 100;
float f;
float g;

   f = a / 3; // f = 33.333333
   g = a + f; // g = 133.333333</pre></div><div class="sect2" title="Comparison Operators for Calculations"><div class="titlepage"><div><div><h3 class="title" id="comparison_operators_for_calculations">Comparison Operators for Calculations</h3></div></div></div><p>We used comparison operators such as <code class="literal">==</code> and <code class="literal">!=</code> with <code class="literal">if</code> statements and digital input signals in Project 5. In addition to these operators, we can also use the following to compare numbers or numerical variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p><code class="literal">&lt;</code> less than</p></li><li class="listitem" style="list-style-type: none"><p><code class="literal">&gt;</code> greater than</p></li><li class="listitem" style="list-style-type: none"><p><code class="literal">&lt;=</code> less than or equal to</p></li><li class="listitem" style="list-style-type: none"><p><code class="literal">&gt;=</code> greater than or equal to</p></li></ul></div><p>We’ve used these comparison operators to compare numbers in lines <span class="gray-background">4</span>, <span class="gray-background">5</span>, and <span class="gray-background">6</span> in the sketch for Project 6 described earlier.</p></div></div><div class="sect1" title="Improving Analog Measurement Precision with a Reference Voltage"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="improving_analog_measurement_precision_w">Improving Analog Measurement Precision with a Reference Voltage</h2></div></div></div><p>As demonstrated in Project 6, the <code class="literal">analogRead()</code> function returns a value proportional to a voltage between 0 and 5 V. The upper value (5 V) is the <span class="emphasis"><em>reference voltage</em></span>, the maximum voltage that the Arduino analog inputs will accept and return the highest value for (1,023).</p><p>To increase precision while reading even lower voltages, we can use a lower reference voltage. For example, when the reference voltage is 5 V, <code class="literal">analogRead()</code> represents this with a value from 0 to 1,023. However, if we need to measure only a voltage with a maximum of (for example) 2 V, then we can alter the Arduino output to represent 2 V using the 0–1,023 value range to allow for more precise measurement. You can do this with either an external or internal reference voltage, as discussed next.</p><div class="sect2" title="Using an External Reference Voltage"><div class="titlepage"><div><div><h3 class="title" id="using_an_external_reference_voltage">Using an External Reference Voltage</h3></div></div></div><p><a id="iddle1034" class="indexterm"/><a id="iddle1416" class="indexterm"/>The first method of using a reference voltage is with the <span class="emphasis"><em>AREF</em></span> (<span class="emphasis"><em>a</em></span>nalog <span class="emphasis"><em>ref</em></span>erence) pin, as shown in <a class="xref" href="ch04.html#arduino_uno_aref_pin" title="Figure 4-32. The Arduino Uno AREF pin">Figure 4-32</a>.</p><div class="figure"><a id="arduino_uno_aref_pin"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00092"/><img src="httpatomoreillycomsourcenostarchimages1629946.png.jpg" alt="The Arduino Uno AREF pin"/></div></div><div class="figure-title">Figure 4-32. The Arduino Uno AREF pin</div></div><p>We can introduce a new reference voltage by connecting the voltage into the AREF pin and the matching GND to the Arduino’s GND. Note that this can lower the reference voltage but will not raise it, because the reference voltage connected to an Arduino Uno must not exceed 5 V. A simple way to set a lower reference voltage is by creating a <span class="emphasis"><em>voltage divider</em></span> with two resistors, as shown in <a class="xref" href="ch04.html#voltage_divider_circuit" title="Figure 4-33. Voltage divider circuit">Figure 4-33</a>.</p><div class="figure"><a id="voltage_divider_circuit"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00093"/><img src="httpatomoreillycomsourcenostarchimages1629948.png.jpg" alt="Voltage divider circuit"/></div></div><div class="figure-title">Figure 4-33. Voltage divider circuit</div></div><p>The values of <span class="emphasis"><em>R1</em></span> and <span class="emphasis"><em>R2</em></span> will determine the reference voltage according to the following formula:</p><div class="informalfigure"><a id="med_id00094a"/><div class="mediaobject"><a id="med_id00094"/><img src="httpatomoreillycomsourcenostarchimages1629950.png.jpg" alt="image with no caption"/></div></div><p><span class="emphasis"><em>V<sub>out</sub></em></span> is the reference voltage, and <span class="emphasis"><em>V<sub>in</sub></em></span> is the input voltage—in this case 5 V. <span class="emphasis"><em>R1</em></span> and <span class="emphasis"><em>R2</em></span> are the resistor values in ohms.</p><p>The simplest way to divide the voltage is to split <span class="emphasis"><em>V<sub>in</sub></em></span> in half by setting <span class="emphasis"><em>R1</em></span> and <span class="emphasis"><em>R2</em></span> to the same value—for example, 10 kΩ each. When you’re doing this, it’s best to use the lowest-tolerance resistors you can find, such as 1 percent; confirm their true resistance values with a multimeter, and use those confirmed values in the calculation. Furthermore, it’s also a very good idea to place a 100 nF capacitor between AREF and GND to avoid a noisy AREF and prevent unstable analog readings.</p><p><a id="iddle1194" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1336" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1387" class="indexterm"/><a id="iddle1417" class="indexterm"/><a id="iddle1427" class="indexterm"/><a id="iddle1550" class="indexterm"/>When using an external reference voltage, insert the following line in the <code class="literal">void setup()</code> section of your sketch:</p><a id="pro_id00031"/><pre class="programlisting"><span class="strong"><strong>analogReference(EXTERNAL); // select AREF pin for reference voltage</strong></span></pre></div><div class="sect2" title="Using the Internal Reference Voltage"><div class="titlepage"><div><div><h3 class="title" id="using_the_internal_reference_voltage">Using the Internal Reference Voltage</h3></div></div></div><p>The Arduino Uno also has an internal 1.1 V reference voltage. If this meets your needs, no hardware changes are required. Just add this line to <code class="literal">void setup()</code>:</p><a id="pro_id00032"/><pre class="programlisting"><span class="strong"><strong>analogReference(INTERNAL); // select internal 1.1 V reference voltage</strong></span></pre></div></div><div class="sect1" title="The Variable Resistor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="variable_resistor">The Variable Resistor</h2></div></div></div><p>Variable resistors, also known as <span class="emphasis"><em>potentiometers</em></span>, can generally be adjusted from 0 Ω up to their rated value. Their schematic symbol is shown in <a class="xref" href="ch04.html#variable_resistor_left_parenthesispotent" title="Figure 4-34. Variable resistor (potentiometer) symbol">Figure 4-34</a>.</p><p>Variable resistors have three pin connections: one in the center pin and one on each side. As the shaft of a variable resistor turns, it increases the resistance between one side and the center and decreases the resistance between the center and the opposite side.</p><p>Variable resistors are available as <span class="emphasis"><em>linear</em></span> and <span class="emphasis"><em>logarithmic</em></span>. The resistance of linear models changes at a constant rate when turning, while the resistance of logarithmic models changes slowly at first and then increases rapidly. Logarithmic potentiometers are used more often in audio amplifier circuits, because they model the human hearing response. Most Arduino projects use linear variable resistors such as the one shown in <a class="xref" href="ch04.html#typical_linear_variable_resistor" title="Figure 4-35. A typical linear variable resistor">Figure 4-35</a>.</p><div class="figure"><a id="variable_resistor_left_parenthesispotent"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00095"/><img src="httpatomoreillycomsourcenostarchimages1629952.png.jpg" alt="Variable resistor (potentiometer) symbol"/></div></div><div class="figure-title">Figure 4-34. Variable resistor (potentiometer) symbol</div></div><div class="figure"><a id="typical_linear_variable_resistor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00096"/><img src="httpatomoreillycomsourcenostarchimages1629954.png.jpg" alt="A typical linear variable resistor"/></div></div><div class="figure-title">Figure 4-35. A typical linear variable resistor</div></div><p><a id="iddle1104" class="indexterm"/><a id="iddle1191" class="indexterm"/><a id="iddle1208" class="indexterm"/><a id="iddle1379" class="indexterm"/><a id="iddle1536" class="indexterm"/>You can also get miniature versions of variable resistors, known as <span class="emphasis"><em>trimpots</em></span> or <span class="emphasis"><em>trimmers</em></span> (see <a class="xref" href="ch04.html#various_trimpots" title="Figure 4-36. Various trimpots">Figure 4-36</a>). Because of their size, trimpots are more useful for making adjustments in circuits, but they’re also very useful for breadboard work because they can be slotted in.</p><div class="figure"><a id="various_trimpots"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00097"/><img src="httpatomoreillycomsourcenostarchimages1629956.png.jpg" alt="Various trimpots"/></div></div><div class="figure-title">Figure 4-36. Various trimpots</div></div><div class="note" title="Note"><h3 class="title"><a id="ch04note06"/>Note</h3><p><span class="emphasis"><em>When shopping for trimpots, take note of the type. Often you will want one that is easy to adjust with a screwdriver that you have on hand, and the enclosed types, as pictured in <a class="xref" href="ch04.html#various_trimpots" title="Figure 4-36. Various trimpots">Figure 4-36</a>, last longer than the cheaper, open contact types.</em></span></p></div></div><div class="sect1" title="Piezoelectric Buzzers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="piezoelectric_buzzers">Piezoelectric Buzzers</h2></div></div></div><p>A <span class="emphasis"><em>piezoelectric element</em></span> (<span class="emphasis"><em>piezo</em></span> for short), or buzzer, is a small, round device that can be used to generate loud and annoying noises that are perfect for alarms—or for having fun. <a class="xref" href="ch04.html#tdk_ps1240_piezo" title="Figure 4-37. TDK PS1240 Piezo">Figure 4-37</a> shows a common example, the TDK PS1240, next to an American quarter, to give you an idea of its size.</p><div class="figure"><a id="tdk_ps1240_piezo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00098"/><img src="httpatomoreillycomsourcenostarchimages1629958.png.jpg" alt="TDK PS1240 Piezo"/></div></div><div class="figure-title">Figure 4-37. TDK PS1240 Piezo</div></div><p>Piezos contain a very thin plate inside the housing that moves when an electrical current is applied. When alternating current is applied (such as on ... off ... on ... off), the plate vibrates and generates sound waves.</p><p>It’s simple to use piezos with Arduino because they can be turned on and off just like an LED. The piezo elements are not polarized and can be connected in either direction.</p><div class="sect2" title="Piezo Schematic"><div class="titlepage"><div><div><h3 class="title" id="piezo_schematic">Piezo Schematic</h3></div></div></div><p><a id="iddle1192" class="indexterm"/><a id="iddle1380" class="indexterm"/>The schematic symbol for the piezo looks like a loudspeaker (<a class="xref" href="ch04.html#piezo_schematic-id00031" title="Figure 4-38. Piezo schematic">Figure 4-38</a>), which makes it easy to recognize.</p><div class="figure"><a id="piezo_schematic-id00031"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00099"/><img src="httpatomoreillycomsourcenostarchimages1629960.png.jpg" alt="Piezo schematic"/></div></div><div class="figure-title">Figure 4-38. Piezo schematic</div></div><div class="note" title="Note"><h3 class="title"><a id="ch04note07"/>Note</h3><p><span class="emphasis"><em>When shopping for a piezo for this project, be sure to get the piezo</em></span> element only <span class="emphasis"><em>type; some buzzer types look like <a class="xref" href="ch04.html#piezo_schematic-id00031" title="Figure 4-38. Piezo schematic">Figure 4-38</a> but include a tone-generating circuit built into the case. We don’t want those because we’re going to drive our tone directly from the Arduino.</em></span></p></div></div></div><div class="sect1" title="Project #7: Trying Out a Piezo Buzzer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash7_trying_out_a_piezo_buzzer">Project #7: Trying Out a Piezo Buzzer</h2></div></div></div><p>If you have a piezo handy and want to try it out, upload the following demonstration sketch to your Arduino:</p><a id="pro_id00033"/><pre class="programlisting">  // Project 7 - Trying Out a Piezo Buzzer
  #define PIEZO 3  // pin 3 is capable of PWM output to drive tones
  int del = 500;
  void setup()
  {
    pinMode(PIEZO, OUTPUT);
  }

  void loop()
  {
<span class="gray-background">1</span>   analogWrite(PIEZO, 128);  // 50 percent duty cycle tone to the piezo
    delay(del);
    digitalWrite(PIEZO, LOW); // turn the piezo off
    delay(del);
  }</pre><p>This sketch uses pulse-width modulation on digital pin three. If you change the duty cycle in the <code class="literal">analogWrite()</code> function (currently it’s 128, which is 50 percent on) at <span class="gray-background">1</span>, then you can alter the volume of the buzzer.</p><p>To increase the volume of your piezo, increase the voltage applied to it. The voltage is currently limited to 5 V, but the buzzer would be much louder at 9 or 12 V. Because higher voltages can’t be sourced from the Arduino, you would need to use an external power source for the buzzer, such as a 9 V battery, and then switch the power into the buzzer using a transistor as an electronic switch. You can use the same sketch with the schematic shown in <a class="xref" href="ch04.html#schematic_for_project_7" title="Figure 4-39. Schematic for Project 7">Figure 4-39</a>.</p><div class="figure"><a id="schematic_for_project_7"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00100"/><img src="httpatomoreillycomsourcenostarchimages1629962.png.jpg" alt="Schematic for Project 7"/></div></div><div class="figure-title">Figure 4-39. Schematic for Project 7</div></div><p>The part of the schematic labeled 12 V will be the positive side of the higher-power supply, whose negative side will connect to the Arduino GND pin.</p></div><div class="sect1" title="Project #8: Creating a Quick-Read Thermometer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash8_creating_a_quick-read_ther">Project #8: Creating a Quick-Read Thermometer</h2></div></div></div><p><a id="iddle1201" class="indexterm"/><a id="iddle1509" class="indexterm"/><a id="iddle1515" class="indexterm"/><a id="iddle1522" class="indexterm"/>Temperature can be represented by an analog signal. We can measure temperature using the TMP36 voltage output temperature sensor made by Analog Devices (<span class="emphasis"><em><a class="ulink" href="http://www.analog.com/tmp36/" target="_top">http://www.analog.com/tmp36/</a></em></span>), shown in <a class="xref" href="ch04.html#tmp36_temperature_sensor" title="Figure 4-40. TMP36 temperature sensor">Figure 4-40</a>.</p><p>Notice that the TMP36 looks just like the BC548 transistor we worked with in the relay control circuit in <a class="xref" href="ch03.html" title="Chapter 3. First Steps">Chapter 3</a>. The TMP36 outputs a voltage that is proportional to the temperature, so you can determine the current temperature using a simple conversion. For example, at 25 degrees Celsius, the output voltage is 750 mV, and each change in temperature of 1 degree results in a change of 10 mV. The TMP36 can measure temperatures between −40 and 125 degrees Celsius.</p><div class="figure"><a id="tmp36_temperature_sensor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00101"/><img src="httpatomoreillycomsourcenostarchimages1629964.png.jpg" alt="TMP36 temperature sensor"/></div></div><div class="figure-title">Figure 4-40. TMP36 temperature sensor</div></div><p>The function <code class="literal">analogRead()</code> will return a value between 0 and 1,023, which corresponds to a voltage between 0 and just under 5,000 mV (5 V). If we multiply the output of <code class="literal">analogRead()</code> by (5,000/1,024), then we will get the actual voltage returned by the sensor. Next, we subtract 500 (an offset used by the TMP36 to allow for temperatures below zero) and then divide by 10, which leaves us with the temperature in degrees Celsius. If you work in Fahrenheit, then multiply the Celsius value by 1.8 and add 32 to the result.</p><div class="sect2" title="The Goal"><div class="titlepage"><div><div><h3 class="title" id="goal-id00032">The Goal</h3></div></div></div><p>In this project, we’ll use the TMP36 to create a quick-read thermometer. When the temperature falls below 20 degrees Celsius, a blue LED turns on. When the temperature is between 20 and 26 degrees, a green LED turns on, and when the temperature is above 26 degrees, a red LED turns on.</p></div><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00033">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Three 560 Ω resistors (R1 to R3)</p></li><li class="listitem"><p>One red LED (LED1)</p></li><li class="listitem"><p>One green LED (LED2)</p></li><li class="listitem"><p>One blue LED (LED3)</p></li><li class="listitem"><p>One TMP36 temperature sensor</p></li><li class="listitem"><p>One breadboard</p></li><li class="listitem"><p>Various connecting wires</p></li><li class="listitem"><p>Arduino and USB cable</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00034">The Schematic</h3></div></div></div><p><a id="iddle1202" class="indexterm"/><a id="iddle1523" class="indexterm"/>The circuit is simple. When you’re looking at the labeled side of the TMP36, the pin on the left connects to the 5 V input, the center pin is the voltage output, and the pin on the right connects to GND as shown in <a class="xref" href="ch04.html#schematic_for_project_8" title="Figure 4-41. Schematic for Project 8">Figure 4-41</a>.</p><div class="figure"><a id="schematic_for_project_8"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00102"/><img src="httpatomoreillycomsourcenostarchimages1629966.png.jpg" alt="Schematic for Project 8"/></div></div><div class="figure-title">Figure 4-41. Schematic for Project 8</div></div></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00035">The Sketch</h3></div></div></div><p>And now for the sketch:</p><a id="pro_id00034"/><pre class="programlisting">  // Project 8 - Creating a Quick-Read Thermometer

  // define the pins that the LEDs are connected to:
  #define HOT    6
  #define NORMAL 4
  #define COLD   2

  float voltage  = 0;
  float celsius  = 0;
  float hotTemp  = 26;
  float coldTemp = 20;
  float sensor = 0;

  void setup()
  {
    pinMode(HOT, OUTPUT);
    pinMode(NORMAL, OUTPUT);
    pinMode(COLD, OUTPUT);
  }

  void loop()
  {
     // read the temperature sensor and convert the result to degrees Celsius
<span class="gray-background">1</span>   sensor = analogRead(0);
    voltage = (sensor*5000)/1024; // convert raw sensor value to millivolts
    voltage = voltage-500;        // remove voltage offset
    celsius = voltage/10;         // convert millivolts to Celsius

    // act on temperature range
<span class="gray-background">2</span>   if ( celsius &lt; coldTemp )
    {
      digitalWrite(COLD, HIGH);
      delay(1000);
      digitalWrite(COLD, LOW);
    }
<span class="gray-background">3</span>   else if ( celsius &gt; coldTemp &amp;&amp; celsius &lt;= hotTemp )
    {
      digitalWrite(NORMAL, HIGH);
      delay(1000);
      digitalWrite(NORMAL, LOW);
    }
    else
    {
      // celsius is &gt; hotTemp
      digitalWrite(HOT, HIGH);
      delay(1000);
      digitalWrite(HOT, LOW);
    }
  }</pre><p>The sketch first reads the voltage from the TMP36 and converts it to temperature in degrees Celsius at <span class="gray-background">1</span>. Next, using the <code class="literal">if-else</code> functions at <span class="gray-background">2</span> and <span class="gray-background">3</span>, the code compares the current temperature against the values for hot and cold and turns on the appropriate LED. The <code class="literal">delay(1000)</code> statements are used to prevent the lights from flashing on and off too quickly if the temperature fluctuates rapidly between two ranges.</p></div><div class="sect2" title="Hacking the Sketch"><div class="titlepage"><div><div><h3 class="title" id="hacking_the_sketch">Hacking the Sketch</h3></div></div></div><p><a id="iddle1389" class="indexterm"/>Although this sketch was rather simple, you could use it as the basis for taking other sorts of readings. You might add a PowerSwitch Tail, for example, as shown in <a class="xref" href="ch04.html#powerswitch_tail_that_switches_up_to_120" title="Figure 4-42. A PowerSwitch Tail that switches up to 120 V AC">Figure 4-42</a>.</p><div class="figure"><a id="powerswitch_tail_that_switches_up_to_120"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00103"/><img src="httpatomoreillycomsourcenostarchimages1629968.png.jpg" alt="A PowerSwitch Tail that switches up to 120 V AC"/></div></div><div class="figure-title">Figure 4-42. A PowerSwitch Tail that switches up to 120 V AC</div></div><p>With a PowerSwitch Tail, you can safely control an appliance that runs from the wall socket, such as a heater, lamp, or another device with a digital output from your Arduino. (For more information, visit <span class="emphasis"><em><a class="ulink" href="http://www.adafruit.com/products/268/" target="_top">http://www.adafruit.com/products/268/</a></em></span>.) For example, you could use a PowerSwitch Tail to build a temperature-controlled heater or fan, control a garage light so it runs for a time and then switches off, or remotely control outdoor Christmas lights.</p></div></div><div class="sect1" title="Looking Ahead"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="looking_ahead-id00036">Looking Ahead</h2></div></div></div><p>And <a class="xref" href="ch04.html" title="Chapter 4. Building Blocks">Chapter 4</a> comes to a close. You now have a lot more tools to work with, including digital inputs and outputs, new types of variables, and various mathematical functions. In the next chapter, you will have a lot more fun with LEDs, learn to create your own functions, build a computer game and electronic dice, and much more.</p></div></section></body></html>
