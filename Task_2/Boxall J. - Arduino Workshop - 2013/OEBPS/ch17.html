<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 17. Data Buses</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="index.html" title="Arduino Workshop: A hands-on introduction with 65 projects"/><link rel="prev" href="ch16.html" title="Chapter 16. Reading RFID Tags"/><link rel="next" href="ch18.html" title="Chapter 18. Real-time Clocks"/></head><body><section class="chapter" title="Chapter 17. Data Buses" epub:type="chapter" id="data_buses"><div class="titlepage"><div><div><h2 class="title">Chapter 17. Data Buses</h2></div></div></div><p>In this chapter you will</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Learn about the I<sup>2</sup>C bus</p></li><li class="listitem"><p>Understand how to use an EEPROM (electrically erasable read-only memory) and a port expander on the I<sup>2</sup>C bus</p></li><li class="listitem"><p>Learn about the SPI bus</p></li><li class="listitem"><p>Learn how to use a digital rheostat on the SPI bus</p></li></ul></div><p>An Arduino communicates with other devices via a <span class="emphasis"><em>data bus</em></span>, a system of connections that allow two or more devices to exchange data in an orderly manner. A data bus can provide a connection between the Arduino and various sensors, I/O expansion devices, and other components.</p><p>The two major buses of most importance to the Arduino are the <span class="emphasis"><em>Serial Peripheral Interface (SPI)</em></span> bus and the <span class="emphasis"><em>Inter-Integrated Circuit bus (I</em></span><sup>2</sup>C). Many useful sensors and external devices communicate using these buses.</p><div class="sect1" title="The I2C Bus"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="i2c_bus">The I<sup>2</sup>C Bus</h2></div></div></div><p><a id="iddle1141" class="indexterm"/><a id="iddle1263" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle1269" class="indexterm"/><a id="iddle1270" class="indexterm"/><a id="iddle1437" class="indexterm"/><a id="iddle1438" class="indexterm"/><a id="iddle1486" class="indexterm"/><a id="iddle1489" class="indexterm"/><a id="iddle1541" class="indexterm"/><a id="iddle1567" class="indexterm"/><a id="iddle1570" class="indexterm"/><a id="iddle1574" class="indexterm"/>The I<sup>2</sup>C bus, also known as the <span class="emphasis"><em>Two Wire Interface (TWI)</em></span> bus, is a simple and easy device used for data communication. Data is transferred between devices and the Arduino through two wires, known as <span class="emphasis"><em>SDA</em></span> and <span class="emphasis"><em>SCL</em></span> (the data line and clock line, respectively). In the case of the Arduino Uno, the SDA pin is A4 and the SCL pin is A5, as shown in <a class="xref" href="ch17.html#i2c_bus_connectors_on_the_arduino_uno" title="Figure 17-1. The I2C bus connectors on the Arduino Uno">Figure 17-1</a>. Some newer R3 boards also have dedicated I<sup>2</sup>C pins at the upper-left corner for convenient access.</p><div class="figure"><a id="i2c_bus_connectors_on_the_arduino_uno"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00272"/><img src="httpatomoreillycomsourcenostarchimages1630314.png.jpg" alt="The I2C bus connectors on the Arduino Uno"/></div></div><div class="figure-title">Figure 17-1. The I<sup>2</sup>C bus connectors on the Arduino Uno</div></div><p>On the I<sup>2</sup>C bus, the Arduino is considered the <span class="emphasis"><em>master device</em></span>, and each IC out on the bus is a <span class="emphasis"><em>slave</em></span>. Each slave has its own address, a hexadecimal number that allows the Arduino to address and communicate with each device. Each device usually has a range of I<sup>2</sup>C bus addresses to choose from, which is detailed in the manufacturer’s data sheet. The particular addresses available are determined by wiring the IC pins a certain way.</p><div class="note" title="Note"><h3 class="title"><a id="ch17note01"/>Note</h3><p><span class="emphasis"><em>Because the Arduino runs on 5 V, your I<sup>2</sup>C device must also operate on 5 V or be able to tolerate it. Always confirm this by contacting the seller or manufacturer before use.</em></span></p></div><p>To use the I<sup>2</sup>C bus, you’ll need to use the <code class="literal">Wire</code> library (included with the Arduino IDE):</p><a id="pro_id00151"/><pre class="programlisting">#include &lt;Wire.h&gt;</pre><p>Next, in <code class="literal">void setup()</code>, activate the bus with this:</p><a id="pro_id00152"/><pre class="programlisting">Wire.begin();</pre><p>Data is transmitted along the bus 1 byte at a time. To send a byte of data from the Arduino to a device on the bus, three functions are required:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The first function initiates communication with the following line of code (where <span class="emphasis"><em><code class="literal">address</code></em></span> is the slave’s bus address in hexadecimal—for example <code class="literal">0x50</code>):</p><a id="pro_id00153"/><pre class="programlisting">Wire.beginTransmission(<span class="emphasis"><em>address</em></span>);</pre></li><li class="listitem"><p>The second function sends 1 byte of data from the Arduino to the device addressed by the previous function (where <code class="literal">data</code> is a variable containing 1 byte of data; you can send more than 1 byte, but you’ll need to use one <code class="literal">Wire.write()</code> for each byte):</p><a id="pro_id00154"/><pre class="programlisting">Wire.write(data);</pre></li><li class="listitem"><p><a id="iddle1161" class="indexterm"/><a id="iddle1162" class="indexterm"/><a id="iddle1164" class="indexterm"/><a id="iddle1268" class="indexterm"/><a id="iddle1485" class="indexterm"/><a id="iddle1568" class="indexterm"/><a id="iddle1569" class="indexterm"/><a id="iddle1572" class="indexterm"/><a id="iddle1573" class="indexterm"/>Finally, once you have finished sending data to a particular device, use this to end the transmission:</p><a id="pro_id00155"/><pre class="programlisting">Wire.endTransmission();</pre></li></ol></div><p>To request that data from an I<sup>2</sup>C device be sent to the Arduino, start with <code class="literal">Wire.beginTransmission(</code><span class="emphasis"><em><code class="literal">address</code></em></span><code class="literal">)</code>, followed by the following (where <span class="emphasis"><em><code class="literal">x</code></em></span> is the number of bytes of data to request):</p><a id="pro_id00156"/><pre class="programlisting">Wire.requestFrom(<span class="emphasis"><em>address</em></span>,<span class="emphasis"><em>x</em></span>);</pre><p>Next, use the following function to store the incoming byte into a variable:</p><a id="pro_id00157"/><pre class="programlisting">incoming = Wire.read(); // incoming is the variable receiving the byte of data</pre><p>Now finalize the transaction with <code class="literal">Wire.endTransmission()</code>, and we’ll put these functions to use in the next project.</p></div><div class="sect1" title="Project #54: Using an External EEPROM"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash54_using_an_external_eeprom">Project #54: Using an External EEPROM</h2></div></div></div><p>In <a class="xref" href="ch16.html" title="Chapter 16. Reading RFID Tags">Chapter 16</a> we used the Arduino’s internal EEPROM to prevent the erasure of variable data caused by a board reset or power failure. The Arduino’s internal EEPROM stores only 1,024 bytes of data. To store more data, you can use external EEPROMs, as you’ll see in this project.</p><div class="figure"><a id="microchip_technologyapostrophes_24lc512"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00273"/><img src="httpatomoreillycomsourcenostarchimages1630316.png.jpg" alt="Microchip Technology’s 24LC512 EEPROM"/></div></div><div class="figure-title">Figure 17-2. Microchip Technology’s 24LC512 EEPROM</div></div><p>For our external EEPROM, we’ll use the Microchip Technology 24LC512 EEPROM, which can store 64KB (65,536 bytes) of data (<a class="xref" href="ch17.html#microchip_technologyapostrophes_24lc512" title="Figure 17-2. Microchip Technology’s 24LC512 EEPROM">Figure 17-2</a>). It’s available from retailers such as Digi-Key (part number 24LC512-I/P-ND) and element14 (part number 1660008).</p><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00136">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>One Microchip Technology 24LC512 EEPROM</p></li><li class="listitem"><p>One breadboard</p></li><li class="listitem"><p>Two 4.7 kΩ resistors</p></li><li class="listitem"><p>One 100 nF ceramic capacitor</p></li><li class="listitem"><p>Various connecting wires</p></li><li class="listitem"><p>Arduino and USB cable</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00137">The Schematic</h3></div></div></div><p>For the circuit, connect each 4.7 kΩ resistor between 5V and SCL and between 5V and SDA, as shown in <a class="xref" href="ch17.html#schematic_for_project_54" title="Figure 17-3. Schematic for Project 54">Figure 17-3</a>.</p><div class="figure"><a id="schematic_for_project_54"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00274"/><img src="httpatomoreillycomsourcenostarchimages1630318.png.jpg" alt="Schematic for Project 54"/></div></div><div class="figure-title">Figure 17-3. Schematic for Project 54</div></div><p>The bus address for the 24LC512 EEPROM IC is partially determined by the way it is wired into the circuit. The last 3 bits of the bus address are determined by the status of pins A2, A1, and A0. When these pins are connected to GND, their values are 0; when they are connected to 5V, their values are 1.</p><p>The first 4 bits are preset as <code class="literal">1010</code>. Therefore, in our circuit, the bus address is represented as <code class="literal">1010000</code> in binary, which is <code class="literal">0x50</code> in hexadecimal. This means that we can use <code class="literal">0x50</code> as the bus address in the sketch.</p></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00138">The Sketch</h3></div></div></div><p>Although our external EEPROM can store up to 64KB of data, our sketch is intended to demonstrate just a bit of its use, so we’ll store and retrieve bytes only in the EEPROM’s first 20 memory positions.</p><p>Enter and upload the following sketch:</p><a id="pro_id00158"/><pre class="programlisting">  // Project 54 - Using an External EEPROM
<span class="gray-background">1</span> #include &lt;Wire.h&gt;
  #define chip1 0x50

  unsigned int pointer;
  byte d=0;

  void setup()
  {
<span class="gray-background">2</span>   Serial.begin(9600);
    Wire.begin();
  }

  void writeData(int device, unsigned int address, byte data)
  // writes a byte of data 'data' to the EEPROM at I2C address 'device'
  // in memory location 'address'
  {
<span class="gray-background">3</span>   Wire.beginTransmission(device);
    Wire.write((byte)(address &gt;&gt; 8));   // left part of pointer address
    Wire.write((byte)(address &amp; 0xFF)); // and the right
    Wire.write(data);
    Wire.endTransmission();
    delay(10);
  }

<span class="gray-background">4</span> byte readData(int device, unsigned int address)
  // reads a byte of data from memory location 'address'
  // in chip at I2C address 'device'
  {
    byte result;  // returned value
    Wire.beginTransmission(device);
    Wire.write((byte)(address &gt;&gt; 8));   // left part of pointer address
    Wire.write((byte)(address &amp; 0xFF)); // and the right
    Wire.endTransmission();
<span class="gray-background">5</span>   Wire.requestFrom(device,1);
    result = Wire.read();
    return result; // and return it as a result of the function readData
  }

  void loop()
  {
    Serial.println("Writing data...");
    for (int a=0; a&lt;20; a++)
    {
      writeData(chip1,a,a);
    }
    Serial.println("Reading data...");
    for (int a=0; a&lt;20; a++)
    {
      Serial.print("EEPROM position ");
      Serial.print(a);
      Serial.print(" holds ");
      d=readData(chip1,a);
      Serial.println(d, DEC);
    }
  }</pre><p>Let’s walk through the sketch. At <span class="gray-background">1</span>, we activate the library and define the I<sup>2</sup>C bus address for the EEPROM as <code class="literal">chip1</code>. At <span class="gray-background">2</span>, we start the Serial Monitor and then the I<sup>2</sup>C bus. The two custom functions <code class="literal">writeData()</code> and <code class="literal">readData()</code> are included to save you time and give you some reusable code for future work with this EEPROM IC. We’ll use them to write and read data, respectively, from the EEPROM.</p><p>The function <code class="literal">writeData()</code> at <span class="gray-background">3</span> initiates transmission with the EEPROM, sends the address of where to store the byte of data in the EEPROM using the next two <code class="literal">Wire.write()</code> functions, sends a byte of data to be written, and then ends transmission.</p><p>The function <code class="literal">readData()</code> at <span class="gray-background">4</span> operates the I<sup>2</sup>C bus in the same manner as <code class="literal">writeData()</code>, but instead of sending a byte of data to the EEPROM, it uses <code class="literal">Wire.requestFrom()</code> to read the data at <span class="gray-background">5</span>. Finally, the byte of data sent from the EEPROM is received into the variable result and becomes the return value for the function.</p></div><div class="sect2" title="The Result"><div class="titlepage"><div><div><h3 class="title" id="result-id00139">The Result</h3></div></div></div><p>In <code class="literal">void loop()</code> the sketch loops 20 times and writes a value to the EEPROM. Then it loops again, retrieving the values and displaying them in the Serial Monitor, as shown in <a class="xref" href="ch17.html#results_of_project_54" title="Figure 17-4. Results of Project 54">Figure 17-4</a>.</p><div class="figure"><a id="results_of_project_54"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00275"/><img src="httpatomoreillycomsourcenostarchimages1630320.png.jpg" alt="Results of Project 54"/></div></div><div class="figure-title">Figure 17-4. Results of Project 54</div></div></div></div><div class="sect1" title="Project #55: Using a Port Expander IC"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash55_using_a_port_expander_ic">Project #55: Using a Port Expander IC</h2></div></div></div><p><a id="iddle1193" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1386" class="indexterm"/>A <span class="emphasis"><em>port expander</em></span> is another useful IC that is controlled via I<sup>2</sup>C. It’s designed to offer more digital outputs. In this project, we’ll use the Microchip Technology MCP23017 16-bit port expander IC (<a class="xref" href="ch17.html#microchip_technologyapostrophes_mcp23017" title="Figure 17-5. Microchip Technology’s MCP23017 port expander IC">Figure 17-5</a>), which has 16 digital outputs to add to your Arduino. It is available from retailers such as Newark (part number 31K2959) or element14 (part number 1332088).</p><div class="figure"><a id="microchip_technologyapostrophes_mcp23017"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00276"/><img src="httpatomoreillycomsourcenostarchimages1630322.png.jpg" alt="Microchip Technology’s MCP23017 port expander IC"/></div></div><div class="figure-title">Figure 17-5. Microchip Technology’s MCP23017 port expander IC</div></div><p>In this project, we’ll connect the MCP23017 to an Arduino and demonstrate how to control the 16 port expander outputs with the Arduino. Each of the port expander’s outputs can be treated like a regular Arduino digital output.</p><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00140">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Arduino and USB cable</p></li><li class="listitem"><p>One breadboard</p></li><li class="listitem"><p>Various connecting wires</p></li><li class="listitem"><p>One Microchip Technology MCP20317 port expander IC</p></li><li class="listitem"><p>Two 4.7 kΩ resistors</p></li><li class="listitem"><p>(Optional) An equal number of 560 Ω resistors and LEDs</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00141">The Schematic</h3></div></div></div><p><a class="xref" href="ch17.html#basic_schematic_for_project_55" title="Figure 17-6. Basic schematic for Project 55">Figure 17-6</a> shows the basic schematic for an MCP23017. As with the EEPROM from Project 54, we can set the I<sup>2</sup>C bus address by using a specific wiring order. With the MCP23017, we connected pins 15 through 17 to GND to set the address to <code class="literal">0x20</code>.</p><p>When you’re working with the MCP23017, it helps to have the pinout diagram from the IC’s data sheet, as shown in <a class="xref" href="ch17.html#pinout_diagram_for_mcp23017" title="Figure 17-7. Pinout diagram for MCP23017">Figure 17-7</a>. Note that the 16 outputs are divided into two banks: GPA7 through GPA0 on the right side and GPB0 through GPB7 on the left. We’ll connect LEDs via 560 Ω resistors from some or all of the outputs to demonstrate when the outputs are being activated.</p><div class="figure"><a id="basic_schematic_for_project_55"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00277"/><img src="httpatomoreillycomsourcenostarchimages1630324.png.jpg" alt="Basic schematic for Project 55"/></div></div><div class="figure-title">Figure 17-6. Basic schematic for Project 55</div></div><div class="figure"><a id="pinout_diagram_for_mcp23017"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00278"/><img src="httpatomoreillycomsourcenostarchimages1630326.png.jpg" alt="Pinout diagram for MCP23017"/></div></div><div class="figure-title">Figure 17-7. Pinout diagram for MCP23017</div></div></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00142">The Sketch</h3></div></div></div><p>Enter and upload the following sketch:</p><a id="pro_id00159"/><pre class="programlisting">  // Project 55 - Using a Port Expander IC

  #include "Wire.h"
  #define mcp23017 0x20

  void setup()
  {
    Wire.begin(); // activate I2C bus
<span class="gray-background">1</span>   // setup MCP23017
    // set I/O pins to outputs
    Wire.beginTransmission(mcp23017);
    Wire.write(0x00); // IODIRA register
    Wire.write(0x00); // set all of bank A to outputs
    Wire.write(0x00); // set all of bank B to outputs
<span class="gray-background">2</span>   Wire.endTransmission();
  }

  void loop()
  {
      Wire.beginTransmission(mcp23017);
      Wire.write(0x12);  
<span class="gray-background">3</span>     Wire.write(255);    // bank A
<span class="gray-background">4</span>     Wire.write(255);    // bank B
      Wire.endTransmission();
      delay(1000);

      Wire.beginTransmission(mcp23017);
      Wire.write(0x12);
      Wire.write(0);    // bank A
      Wire.write(0);    // bank B
      Wire.endTransmission();
      delay(1000);
  }</pre><p><a id="iddle1357" class="indexterm"/><a id="iddle1359" class="indexterm"/><a id="iddle1436" class="indexterm"/><a id="iddle1482" class="indexterm"/><a id="iddle1494" class="indexterm"/>To use the MCP23017, we need the lines listed in <code class="literal">void setup()</code> from <span class="gray-background">1</span> through <span class="gray-background">2</span>. To turn on and off the outputs on each bank, we send 1 byte representing each bank in order; that is, we send a value for bank GPA0 through GPA7 and then a value for GPB0 through GPB7.</p><p>When setting individual pins, you can think of each bank as a binary number (as explained in <a class="xref" href="ch06.html#quick_course_in_binary" title="A Quick Course in Binary">A Quick Course in Binary</a>). Thus, to turn on pins 7 through 4, you would send the number 11110000 in binary (240 in decimal), inserted into the <code class="literal">Wire.write()</code> function shown at <span class="gray-background">3</span> for bank GPA0 through GPA7 or <span class="gray-background">4</span> for bank GPB0 through GPB7.</p><p>Hundreds of devices use the I<sup>2</sup>C bus for communication. Now that you know the basics of how to use these buses, you can use any of them with an Arduino board.</p></div></div><div class="sect1" title="The SPI Bus"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="spi_bus">The SPI Bus</h2></div></div></div><p>The SPI bus differs from the I<sup>2</sup>C bus in that it can be used to send data to and receive data from a device simultaneously and at different speeds, depending on the microcontroller used. Communication, however, is also <span class="emphasis"><em>master-slave</em></span>: The Arduino acts as the <span class="emphasis"><em>master</em></span> and determines which device (the <span class="emphasis"><em>slave</em></span>) it will communicate with at one time.</p><div class="sect2" title="Pin Connections"><div class="titlepage"><div><div><h3 class="title" id="pin_connections">Pin Connections</h3></div></div></div><p><a id="iddle1483" class="indexterm"/><a id="iddle1487" class="indexterm"/><a id="iddle1490" class="indexterm"/>Each SPI device uses four pins to communicate with a master: <span class="emphasis"><em>MOSI</em></span> (Master-Out, Slave-In), <span class="emphasis"><em>MISO</em></span> (Master-In, Slave-Out), <span class="emphasis"><em>SCK</em></span> (clock), and <span class="emphasis"><em>SS</em></span> or <span class="emphasis"><em>CS</em></span> (Slave Select or Chip Select). These SPI pins are connected to the Arduino as shown in <a class="xref" href="ch17.html#spi_pins_on_an_arduino_uno" title="Figure 17-8. SPI pins on an Arduino Uno">Figure 17-8</a>.</p><div class="figure"><a id="spi_pins_on_an_arduino_uno"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00279"/><img src="httpatomoreillycomsourcenostarchimages1630328.png.jpg" alt="SPI pins on an Arduino Uno"/></div></div><div class="figure-title">Figure 17-8. SPI pins on an Arduino Uno</div></div><p>A typical single Arduino-to-SPI device connection is shown in <a class="xref" href="ch17.html#typical_arduino-to-spi_device_connection" title="Figure 17-9. Typical Arduino-to-SPI device connection">Figure 17-9</a>. Arduino pins D11 through D13 are reserved for SPI, but the SS pin can use any other digital pin (often D10 is used because it’s next to the SPI pins).</p><div class="figure"><a id="typical_arduino-to-spi_device_connection"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00280"/><img src="httpatomoreillycomsourcenostarchimages1630330.png.jpg" alt="Typical Arduino-to-SPI device connection"/></div></div><div class="figure-title">Figure 17-9. Typical Arduino-to-SPI device connection</div></div><div class="note" title="Note"><h3 class="title"><a id="ch17note02"/>Note</h3><p><span class="emphasis"><em>As with I<sup>2</sup>C devices, your SPI device must either operate on 5 V or tolerate it since the Arduino runs on 5 V. Be sure to check this out with the seller or manufacturer before use.</em></span></p></div></div><div class="sect2" title="Implementing the SPI"><div class="titlepage"><div><div><h3 class="title" id="implementing_the_spi">Implementing the SPI</h3></div></div></div><p>Now let’s examine how to implement the SPI bus in a sketch. Before doing this, however, we’ll run through the functions used. First is the <code class="literal">SPI</code> library (included with the Arduino IDE software):</p><a id="pro_id00160"/><pre class="programlisting">#include "SPI.h"</pre><p>Next, you need to choose a pin to be used for SS and set it as a digital output in <code class="literal">void setup</code>. Because we’re using only one SPI device in our example, we’ll use D10 and set it up <code class="literal">HIGH</code> first, because most SPI devices have an “active low” SS pin:</p><a id="pro_id00161"/><pre class="programlisting">pinMode(10, OUTPUT);
digitalWrite(10, HIGH);</pre><p><a id="iddle1481" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1492" class="indexterm"/>Here is the function to activate the SPI bus:</p><a id="pro_id00162"/><pre class="programlisting">SPI.begin();</pre><p>Finally, we need to tell the sketch which way to send and receive data. Some SPI devices require that their data be sent with the Most Significant Bit (MSB) first, and some want the MSB last. (Again, see <a class="xref" href="ch06.html#quick_course_in_binary" title="A Quick Course in Binary">A Quick Course in Binary</a> for more on MSB.) Therefore, in <code class="literal">void setup</code> we use the following function after <code class="literal">SPI.begin</code>:</p><a id="pro_id00163"/><pre class="programlisting">SPI.setBitOrder(<span class="emphasis"><em>order</em></span>);</pre><p>Here, <span class="emphasis"><em><code class="literal">order</code></em></span> is either <code class="literal">MSBFIRST</code> or <code class="literal">MSBLAST</code>.</p></div><div class="sect2" title="Sending Data to an SPI Device"><div class="titlepage"><div><div><h3 class="title" id="sending_data_to_an_spi_device">Sending Data to an SPI Device</h3></div></div></div><p>To send data to an SPI device, we first set the SS pin to <code class="literal">LOW</code>, which tells the SPI device that the master (the Arduino) wants to communicate with it. Next, we send bytes of data to the device with the following line, as often as necessary—that is, you use this once for each byte you are sending:</p><a id="pro_id00164"/><pre class="programlisting">SPI.transfer(byte);</pre><p>After you’ve finished communicating with the device, set the SS pin to <code class="literal">HIGH</code> to tell the device that the Arduino has finished communicating with it.</p><p>Each SPI device requires a separate SS pin. For example, if you had two SPI devices, the second SPI device’s SS pin could be D9 and connected to the Arduino as shown in <a class="xref" href="ch17.html#two_spi_devices_connected_to_one_arduino" title="Figure 17-10. Two SPI devices connected to one Arduino">Figure 17-10</a>.</p><div class="figure"><a id="two_spi_devices_connected_to_one_arduino"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00281"/><img src="httpatomoreillycomsourcenostarchimages1630332.png.jpg" alt="Two SPI devices connected to one Arduino"/></div></div><div class="figure-title">Figure 17-10. Two SPI devices connected to one Arduino</div></div><p>When communicating with the second slave device, you would use the D9 (instead of the D10) SS pin before and after communication.</p><p>Project 56 demonstrates using the SPI bus with a digital rheostat.</p></div></div><div class="sect1" title="Project #56: Using a Digital Rheostat"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="project_hash56_using_a_digital_rheostat">Project #56: Using a Digital Rheostat</h2></div></div></div><p><a id="iddle1153" class="indexterm"/><a id="iddle1176" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1484" class="indexterm"/>In simple terms, a <span class="emphasis"><em>rheostat</em></span> device is similar to the potentiometers we examined in <a class="xref" href="ch04.html" title="Chapter 4. Building Blocks">Chapter 4</a>, except the rheostat has two pins: one for the wiper and one for the return current. In this project, you’ll use a digital rheostat to set the resistance in the sketch instead of physically turning a potentiometer knob or shaft yourself. Rheostats are often the basis of volume controls in audio equipment that use buttons rather than dials. The tolerance of a rheostat is much larger than that of a normal fixed-value resistor—in some cases, around 20 percent larger.</p><p>For Project 56, we will use the Microchip Technology MCP4162 shown in <a class="xref" href="ch17.html#microchip_technologyapostrophes_mcp4162" title="Figure 17-11. Microchip Technology’s MCP4162 digital rheostat">Figure 17-11</a>. The MCP4162 is available in various resistance values; this example uses the 10 kΩ version. It is available from retailers such as Newark (part number 77M2766) and element14 (part number 1840698). The resistance can be adjusted in 255 steps; each step has a resistance of around 40 Ω. To select a particular step, we send 2 bytes of data to a command byte (which is 0) and the value byte (which is between 0 and 255). The MCP4162 uses nonvolatile memory, so once the power is disconnected and later connected, the last value selected is still in effect.</p><div class="figure"><a id="microchip_technologyapostrophes_mcp4162"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00282"/><img src="httpatomoreillycomsourcenostarchimages1630334.png.jpg" alt="Microchip Technology’s MCP4162 digital rheostat"/></div></div><div class="figure-title">Figure 17-11. Microchip Technology’s MCP4162 digital rheostat</div></div><p>We’ll control the brightness of an LED using the rheostat.</p><div class="sect2" title="The Hardware"><div class="titlepage"><div><div><h3 class="title" id="hardware-id00143">The Hardware</h3></div></div></div><p>Here’s what you’ll need to create this project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Arduino and USB cable</p></li><li class="listitem"><p>One breadboard</p></li><li class="listitem"><p>Various connecting wires</p></li><li class="listitem"><p>One Microchip Technology MCP4162 digital rheostat</p></li><li class="listitem"><p>One 560 Ω resistor</p></li><li class="listitem"><p>One LED</p></li></ul></div></div><div class="sect2" title="The Schematic"><div class="titlepage"><div><div><h3 class="title" id="schematic-id00144">The Schematic</h3></div></div></div><p><a class="xref" href="ch17.html#schematic_for_project_56" title="Figure 17-12. Schematic for Project 56">Figure 17-12</a> shows the schematic. The pin numbering on the MCP4162 starts at the top left of the package. Pin 1 is indicated by the indented dot to the left of the Microchip logo on the IC (see <a class="xref" href="ch17.html#microchip_technologyapostrophes_mcp4162" title="Figure 17-11. Microchip Technology’s MCP4162 digital rheostat">Figure 17-11</a>).</p><div class="figure"><a id="schematic_for_project_56"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00283"/><img src="httpatomoreillycomsourcenostarchimages1630336.png.jpg" alt="Schematic for Project 56"/></div></div><div class="figure-title">Figure 17-12. Schematic for Project 56</div></div></div><div class="sect2" title="The Sketch"><div class="titlepage"><div><div><h3 class="title" id="sketch-id00145">The Sketch</h3></div></div></div><p>Enter and upload the following sketch:</p><a id="pro_id00165"/><pre class="programlisting">  // Project 56 - Using a Digital Rheostat

<span class="gray-background">1</span> #include "SPI.h" // necessary library
  int ss=10;       // using digital pin 10 for SPI slave select
  int del=200;     // used for delaying the steps between LED brightness values

  void setup()
  {
<span class="gray-background">2</span>   SPI.begin();
    pinMode(ss, OUTPUT);    // we use this for the SS pin
    digitalWrite(ss, HIGH); // the SS pin is active low, so set it up high first
<span class="gray-background">3</span>   SPI.setBitOrder(MSBFIRST);
    // our MCP4162 requires data to be sent MSB (most significant byte) first

  }

<span class="gray-background">4</span> void setValue(int value)
  {
    digitalWrite(ss, LOW);
   SPI.transfer(0); // send the command byte
    SPI.transfer(value); // send the value (0 to 255)
    digitalWrite(ss, HIGH);
  }

  void loop()
  {
<span class="gray-background">5</span>   for (int a=0; a&lt;256; a++)
    {
      setValue(a);
      delay(del);
    }
<span class="gray-background">6</span>   for (int a=255; a&gt;=0; a--)
    {
      setValue(a);
      delay(del);
    }
  }</pre><p>Let’s walk through the code. First, we set up the SPI bus at <span class="gray-background">1</span> and <span class="gray-background">2</span>. At <span class="gray-background">3</span>, we set the byte direction to suit the MPC4162. To make setting the resistance easier, we use the custom function at <span class="gray-background">4</span>, which accepts the resistance step (0 through 255) and passes it to the MCP4162. Finally, the sketch uses two loops to move the rheostat through all the stages, from zero to the maximum at <span class="gray-background">5</span> and then back to zero at <span class="gray-background">6</span>. This last piece should make the LED increase and decrease in brightness, fading up and down for as long as the sketch is running.</p></div></div><div class="sect1" title="Looking Ahead"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="looking_ahead-id00146">Looking Ahead</h2></div></div></div><p>In this chapter you learned about and experimented with two important Arduino communication methods. Now you’re ready to interface your Arduino with a huge variety of sensors, more advanced components, and other items as they become available on the market. One of the most popular components today is a real-time clock IC that allows your projects to keep and work with time—and that’s the topic of <a class="xref" href="ch18.html" title="Chapter 18. Real-time Clocks">Chapter 18</a>. So let’s go!</p></div></section></body></html>
